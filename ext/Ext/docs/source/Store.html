<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-Store-method-constructor'><span id='Ext-data-Store'>/**
</span></span> * @class Ext.data.Store
 * @extends Ext.util.Observable
 * &lt;p&gt;The Store class encapsulates a client side cache of {@link Ext.data.Record Record}
 * objects which provide input data for Components such as the {@link Ext.grid.GridPanel GridPanel},
 * the {@link Ext.form.ComboBox ComboBox}, or the {@link Ext.DataView DataView}.&lt;/p&gt;
 * &lt;p&gt;&lt;u&gt;Retrieving Data&lt;/u&gt;&lt;/p&gt;
 * &lt;p&gt;A Store object may access a data object using:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
 * &lt;li&gt;{@link #proxy configured implementation} of {@link Ext.data.DataProxy DataProxy}&lt;/li&gt;
 * &lt;li&gt;{@link #data} to automatically pass in data&lt;/li&gt;
 * &lt;li&gt;{@link #loadData} to manually pass in data&lt;/li&gt;
 * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
 * &lt;p&gt;&lt;u&gt;Reading Data&lt;/u&gt;&lt;/p&gt;
 * &lt;p&gt;A Store object has no inherent knowledge of the format of the data object (it could be
 * an Array, XML, or JSON). A Store object uses an appropriate {@link #reader configured implementation}
 * of a {@link Ext.data.DataReader DataReader} to create {@link Ext.data.Record Record} instances from the data
 * object.&lt;/p&gt;
 * &lt;p&gt;&lt;u&gt;Store Types&lt;/u&gt;&lt;/p&gt;
 * &lt;p&gt;There are several implementations of Store available which are customized for use with
 * a specific DataReader implementation.  Here is an example using an ArrayStore which implicitly
 * creates a reader commensurate to an Array data object.&lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
var myStore = new Ext.data.ArrayStore({
    fields: ['fullname', 'first'],
    idIndex: 0 // id for each record will be the first element
});
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;For custom implementations create a basic {@link Ext.data.Store} configured as needed:&lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
// create a {@link Ext.data.Record Record} constructor:
var rt = Ext.data.Record.create([
    {name: 'fullname'},
    {name: 'first'}
]);
var myStore = new Ext.data.Store({
    // explicitly create reader
    reader: new Ext.data.ArrayReader(
        {
            idIndex: 0  // id for each record will be the first element
        },
        rt // recordType
    )
});
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;Load some data into store (note the data object is an array which corresponds to the reader):&lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
var myData = [
    [1, 'Fred Flintstone', 'Fred'],  // note that id for the record is the first element
    [2, 'Barney Rubble', 'Barney']
];
myStore.loadData(myData);
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;Records are cached and made available through accessor functions.  An example of adding
 * a record to the store:&lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
var defaultData = {
    fullname: 'Full Name',
    first: 'First Name'
};
var recId = 100; // provide unique id for the record
var r = new myStore.recordType(defaultData, ++recId); // create new record
myStore.{@link #insert}(0, r); // insert a new record into the store (also see {@link #add})
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;&lt;u&gt;Writing Data&lt;/u&gt;&lt;/p&gt;
 * &lt;p&gt;And &lt;b&gt;new in Ext version 3&lt;/b&gt;, use the new {@link Ext.data.DataWriter DataWriter} to create an automated, &lt;a href=&quot;http://extjs.com/deploy/dev/examples/writer/writer.html&quot;&gt;Writable Store&lt;/a&gt;
 * along with &lt;a href=&quot;http://extjs.com/deploy/dev/examples/restful/restful.html&quot;&gt;RESTful features.&lt;/a&gt;
 * @constructor
 * Creates a new Store.
 * @param {Object} config A config object containing the objects needed for the Store to access data,
 * and read the data into Records.
 * @xtype store
 */
Ext.data.Store = Ext.extend(Ext.util.Observable, {
<span id='Ext-data-Store-cfg-storeId'>    /**
</span>     * @cfg {String} storeId If passed, the id to use to register with the &lt;b&gt;{@link Ext.StoreMgr StoreMgr}&lt;/b&gt;.
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: if a (deprecated) &lt;tt&gt;{@link #id}&lt;/tt&gt; is specified it will supersede the &lt;tt&gt;storeId&lt;/tt&gt;
     * assignment.&lt;/p&gt;
     */
<span id='Ext-data-Store-cfg-url'>    /**
</span>     * @cfg {String} url If a &lt;tt&gt;{@link #proxy}&lt;/tt&gt; is not specified the &lt;tt&gt;url&lt;/tt&gt; will be used to
     * implicitly configure a {@link Ext.data.HttpProxy HttpProxy} if an &lt;tt&gt;url&lt;/tt&gt; is specified.
     * Typically this option, or the &lt;code&gt;{@link #data}&lt;/code&gt; option will be specified.
     */
<span id='Ext-data-Store-cfg-autoLoad'>    /**
</span>     * @cfg {Boolean/Object} autoLoad If &lt;tt&gt;{@link #data}&lt;/tt&gt; is not specified, and if &lt;tt&gt;autoLoad&lt;/tt&gt;
     * is &lt;tt&gt;true&lt;/tt&gt; or an &lt;tt&gt;Object&lt;/tt&gt;, this store's {@link #load} method is automatically called
     * after creation. If the value of &lt;tt&gt;autoLoad&lt;/tt&gt; is an &lt;tt&gt;Object&lt;/tt&gt;, this &lt;tt&gt;Object&lt;/tt&gt; will
     * be passed to the store's {@link #load} method.
     */
<span id='Ext-data-Store-cfg-proxy'>    /**
</span>     * @cfg {Ext.data.DataProxy} proxy The {@link Ext.data.DataProxy DataProxy} object which provides
     * access to a data object.  See &lt;code&gt;{@link #url}&lt;/code&gt;.
     */
<span id='Ext-data-Store-cfg-data'>    /**
</span>     * @cfg {Array} data An inline data object readable by the &lt;code&gt;{@link #reader}&lt;/code&gt;.
     * Typically this option, or the &lt;code&gt;{@link #url}&lt;/code&gt; option will be specified.
     */
<span id='Ext-data-Store-cfg-reader'>    /**
</span>     * @cfg {Ext.data.DataReader} reader The {@link Ext.data.DataReader Reader} object which processes the
     * data object and returns an Array of {@link Ext.data.Record} objects which are cached keyed by their
     * &lt;b&gt;&lt;tt&gt;{@link Ext.data.Record#id id}&lt;/tt&gt;&lt;/b&gt; property.
     */
<span id='Ext-data-Store-cfg-writer'>    /**
</span>     * @cfg {Ext.data.DataWriter} writer
     * &lt;p&gt;The {@link Ext.data.DataWriter Writer} object which processes a record object for being written
     * to the server-side database.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;When a writer is installed into a Store the {@link #add}, {@link #remove}, and {@link #update}
     * events on the store are monitored in order to remotely {@link #createRecords create records},
     * {@link #destroyRecord destroy records}, or {@link #updateRecord update records}.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;The proxy for this store will relay any {@link #writexception} events to this store.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;Sample implementation:
     * &lt;pre&gt;&lt;code&gt;
var writer = new {@link Ext.data.JsonWriter}({
    encode: true,
    writeAllFields: true // write all fields, not just those that changed
});

// Typical Store collecting the Proxy, Reader and Writer together.
var store = new Ext.data.Store({
    storeId: 'user',
    root: 'records',
    proxy: proxy,
    reader: reader,
    writer: writer,     // &lt;-- plug a DataWriter into the store just as you would a Reader
    paramsAsHash: true,
    autoSave: false    // &lt;-- false to delay executing create, update, destroy requests
                        //     until specifically told to do so.
});
     * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     */
    writer : undefined,
<span id='Ext-data-Store-cfg-baseParams'>    /**
</span>     * @cfg {Object} baseParams
     * &lt;p&gt;An object containing properties which are to be sent as parameters
     * for &lt;i&gt;every&lt;/i&gt; HTTP request.&lt;/p&gt;
     * &lt;p&gt;Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: &lt;code&gt;baseParams&lt;/code&gt; may be superseded by any &lt;code&gt;params&lt;/code&gt;
     * specified in a &lt;code&gt;{@link #load}&lt;/code&gt; request, see &lt;code&gt;{@link #load}&lt;/code&gt;
     * for more details.&lt;/p&gt;
     * This property may be modified after creation using the &lt;code&gt;{@link #setBaseParam}&lt;/code&gt;
     * method.
     */
<span id='Ext-data-Store-cfg-sortInfo'>    /**
</span>     * @cfg {Object} sortInfo A config object to specify the sort order in the request of a Store's
     * {@link #load} operation.  Note that for local sorting, the &lt;tt&gt;direction&lt;/tt&gt; property is
     * case-sensitive. See also {@link #remoteSort} and {@link #paramNames}.
     * For example:&lt;pre&gt;&lt;code&gt;
sortInfo: {
    field: 'fieldName',
    direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
}
&lt;/code&gt;&lt;/pre&gt;
     */
<span id='Ext-data-Store-cfg-remoteSort'>    /**
</span>     * @cfg {boolean} remoteSort &lt;tt&gt;true&lt;/tt&gt; if sorting is to be handled by requesting the &lt;tt&gt;{@link #proxy Proxy}&lt;/tt&gt;
     * to provide a refreshed version of the data object in sorted order, as opposed to sorting the Record cache
     * in place (defaults to &lt;tt&gt;false&lt;/tt&gt;).
     * &lt;p&gt;If &lt;tt&gt;remoteSort&lt;/tt&gt; is &lt;tt&gt;true&lt;/tt&gt;, then clicking on a {@link Ext.grid.Column Grid Column}'s
     * {@link Ext.grid.Column#header header} causes the current page to be requested from the server appending
     * the following two parameters to the &lt;b&gt;&lt;tt&gt;{@link #load params}&lt;/tt&gt;&lt;/b&gt;:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;sort&lt;/tt&gt;&lt;/b&gt; : String&lt;p class=&quot;sub-desc&quot;&gt;The &lt;tt&gt;name&lt;/tt&gt; (as specified in the Record's
     * {@link Ext.data.Field Field definition}) of the field to sort on.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;dir&lt;/tt&gt;&lt;/b&gt; : String&lt;p class=&quot;sub-desc&quot;&gt;The direction of the sort, 'ASC' or 'DESC' (case-sensitive).&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;&lt;/p&gt;
     */
    remoteSort : false,

<span id='Ext-data-Store-cfg-autoDestroy'>    /**
</span>     * @cfg {Boolean} autoDestroy &lt;tt&gt;true&lt;/tt&gt; to destroy the store when the component the store is bound
     * to is destroyed (defaults to &lt;tt&gt;false&lt;/tt&gt;).
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: this should be set to true when using stores that are bound to only 1 component.&lt;/p&gt;
     */
    autoDestroy : false,

<span id='Ext-data-Store-cfg-pruneModifiedRecords'>    /**
</span>     * @cfg {Boolean} pruneModifiedRecords &lt;tt&gt;true&lt;/tt&gt; to clear all modified record information each time
     * the store is loaded or when a record is removed (defaults to &lt;tt&gt;false&lt;/tt&gt;). See {@link #getModifiedRecords}
     * for the accessor method to retrieve the modified records.
     */
    pruneModifiedRecords : false,

<span id='Ext-data-Store-property-lastOptions'>    /**
</span>     * Contains the last options object used as the parameter to the {@link #load} method. See {@link #load}
     * for the details of what this may contain. This may be useful for accessing any params which were used
     * to load the current Record cache.
     * @property
     */
    lastOptions : null,

<span id='Ext-data-Store-cfg-autoSave'>    /**
</span>     * @cfg {Boolean} autoSave
     * &lt;p&gt;Defaults to &lt;tt&gt;true&lt;/tt&gt; causing the store to automatically {@link #save} records to
     * the server when a record is modified (ie: becomes 'dirty'). Specify &lt;tt&gt;false&lt;/tt&gt; to manually call {@link #save}
     * to send all modifiedRecords to the server.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: each CRUD action will be sent as a separate request.&lt;/p&gt;
     */
    autoSave : true,

<span id='Ext-data-Store-cfg-batch'>    /**
</span>     * @cfg {Boolean} batch
     * &lt;p&gt;Defaults to &lt;tt&gt;true&lt;/tt&gt; (unless &lt;code&gt;{@link #restful}:true&lt;/code&gt;). Multiple
     * requests for each CRUD action (CREATE, READ, UPDATE and DESTROY) will be combined
     * and sent as one transaction. Only applies when &lt;code&gt;{@link #autoSave}&lt;/code&gt; is set
     * to &lt;tt&gt;false&lt;/tt&gt;.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;If Store is RESTful, the DataProxy is also RESTful, and a unique transaction is
     * generated for each record.&lt;/p&gt;
     */
    batch : true,

<span id='Ext-data-Store-cfg-restful'>    /**
</span>     * @cfg {Boolean} restful
     * Defaults to &lt;tt&gt;false&lt;/tt&gt;.  Set to &lt;tt&gt;true&lt;/tt&gt; to have the Store and the set
     * Proxy operate in a RESTful manner. The store will automatically generate GET, POST,
     * PUT and DELETE requests to the server. The HTTP method used for any given CRUD
     * action is described in {@link Ext.data.Api#restActions}.  For additional information
     * see {@link Ext.data.DataProxy#restful}.
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: if &lt;code&gt;{@link #restful}:true&lt;/code&gt; &lt;code&gt;batch&lt;/code&gt; will
     * internally be set to &lt;tt&gt;false&lt;/tt&gt;.&lt;/p&gt;
     */
    restful: false,

<span id='Ext-data-Store-cfg-paramNames'>    /**
</span>     * @cfg {Object} paramNames
     * &lt;p&gt;An object containing properties which specify the names of the paging and
     * sorting parameters passed to remote servers when loading blocks of data. By default, this
     * object takes the following form:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
{
    start : 'start',  // The parameter name which specifies the start row
    limit : 'limit',  // The parameter name which specifies number of rows to return
    sort : 'sort',    // The parameter name which specifies the column to sort on
    dir : 'dir'       // The parameter name which specifies the sort direction
}
&lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;The server must produce the requested data block upon receipt of these parameter names.
     * If different parameter names are required, this property can be overriden using a configuration
     * property.&lt;/p&gt;
     * &lt;p&gt;A {@link Ext.PagingToolbar PagingToolbar} bound to this Store uses this property to determine
     * the parameter names to use in its {@link #load requests}.
     */
    paramNames : undefined,

<span id='Ext-data-Store-cfg-defaultParamNames'>    /**
</span>     * @cfg {Object} defaultParamNames
     * Provides the default values for the {@link #paramNames} property. To globally modify the parameters
     * for all stores, this object should be changed on the store prototype.
     */
    defaultParamNames : {
        start : 'start',
        limit : 'limit',
        sort : 'sort',
        dir : 'dir'
    },

<span id='Ext-data-Store-property-isDestroyed'>    isDestroyed: false,
</span><span id='Ext-data-Store-property-hasMultiSort'>    hasMultiSort: false,
</span>
<span id='Ext-data-Store-property-batchKey'>    // private
</span>    batchKey : '_ext_batch_',

    constructor : function(config){
<span id='Ext-data-Store-property-hasMultiSort'>        /**
</span>         * @property hasMultiSort
         * @type Boolean
         * True if this store is currently sorted by more than one field/direction combination.
         */

<span id='Ext-data-Store-property-isDestroyed'>        /**
</span>         * @property isDestroyed
         * @type Boolean
         * True if the store has been destroyed already. Read only
         */

        this.data = new Ext.util.MixedCollection(false);
        this.data.getKey = function(o){
            return o.id;
        };


        // temporary removed-records cache
        this.removed = [];

        if(config &amp;&amp; config.data){
            this.inlineData = config.data;
            delete config.data;
        }

        Ext.apply(this, config);

<span id='Ext-data-Store-property-baseParams'>        /**
</span>         * See the &lt;code&gt;{@link #baseParams corresponding configuration option}&lt;/code&gt;
         * for a description of this property.
         * To modify this property see &lt;code&gt;{@link #setBaseParam}&lt;/code&gt;.
         * @property
         */
        this.baseParams = Ext.isObject(this.baseParams) ? this.baseParams : {};

        this.paramNames = Ext.applyIf(this.paramNames || {}, this.defaultParamNames);

        if((this.url || this.api) &amp;&amp; !this.proxy){
            this.proxy = new Ext.data.HttpProxy({url: this.url, api: this.api});
        }
        // If Store is RESTful, so too is the DataProxy
        if (this.restful === true &amp;&amp; this.proxy) {
            // When operating RESTfully, a unique transaction is generated for each record.
            // TODO might want to allow implemention of faux REST where batch is possible using RESTful routes only.
            this.batch = false;
            Ext.data.Api.restify(this.proxy);
        }

        if(this.reader){ // reader passed
            if(!this.recordType){
                this.recordType = this.reader.recordType;
            }
            if(this.reader.onMetaChange){
                this.reader.onMetaChange = this.reader.onMetaChange.createSequence(this.onMetaChange, this);
            }
            if (this.writer) { // writer passed
                if (this.writer instanceof(Ext.data.DataWriter) === false) {    // &lt;-- config-object instead of instance.
                    this.writer = this.buildWriter(this.writer);
                }
                this.writer.meta = this.reader.meta;
                this.pruneModifiedRecords = true;
            }
        }

<span id='Ext-data-Store-property-recordType'>        /**
</span>         * The {@link Ext.data.Record Record} constructor as supplied to (or created by) the
         * {@link Ext.data.DataReader Reader}. Read-only.
         * &lt;p&gt;If the Reader was constructed by passing in an Array of {@link Ext.data.Field} definition objects,
         * instead of a Record constructor, it will implicitly create a Record constructor from that Array (see
         * {@link Ext.data.Record}.{@link Ext.data.Record#create create} for additional details).&lt;/p&gt;
         * &lt;p&gt;This property may be used to create new Records of the type held in this Store, for example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
    // create the data store
    var store = new Ext.data.ArrayStore({
        autoDestroy: true,
        fields: [
           {name: 'company'},
           {name: 'price', type: 'float'},
           {name: 'change', type: 'float'},
           {name: 'pctChange', type: 'float'},
           {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
        ]
    });
    store.loadData(myData);

    // create the Grid
    var grid = new Ext.grid.EditorGridPanel({
        store: store,
        colModel: new Ext.grid.ColumnModel({
            columns: [
                {id:'company', header: 'Company', width: 160, dataIndex: 'company'},
                {header: 'Price', renderer: 'usMoney', dataIndex: 'price'},
                {header: 'Change', renderer: change, dataIndex: 'change'},
                {header: '% Change', renderer: pctChange, dataIndex: 'pctChange'},
                {header: 'Last Updated', width: 85,
                    renderer: Ext.util.Format.dateRenderer('m/d/Y'),
                    dataIndex: 'lastChange'}
            ],
            defaults: {
                sortable: true,
                width: 75
            }
        }),
        autoExpandColumn: 'company', // match the id specified in the column model
        height:350,
        width:600,
        title:'Array Grid',
        tbar: [{
            text: 'Add Record',
            handler : function(){
                var defaultData = {
                    change: 0,
                    company: 'New Company',
                    lastChange: (new Date()).clearTime(),
                    pctChange: 0,
                    price: 10
                };
                var recId = 3; // provide unique id
                var p = new store.recordType(defaultData, recId); // create new record
                grid.stopEditing();
                store.{@link #insert}(0, p); // insert a new record into the store (also see {@link #add})
                grid.startEditing(0, 0);
            }
        }]
    });
         * &lt;/code&gt;&lt;/pre&gt;
         * @property recordType
         * @type Function
         */

        if(this.recordType){
<span id='Ext-data-Store-property-fields'>            /**
</span>             * A {@link Ext.util.MixedCollection MixedCollection} containing the defined {@link Ext.data.Field Field}s
             * for the {@link Ext.data.Record Records} stored in this Store. Read-only.
             * @property fields
             * @type Ext.util.MixedCollection
             */
            this.fields = this.recordType.prototype.fields;
        }
        this.modified = [];

        this.addEvents(
<span id='Ext-data-Store-event-datachanged'>            /**
</span>             * @event datachanged
             * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
             * widget that is using this Store as a Record cache should refresh its view.
             * @param {Store} this
             */
            'datachanged',
<span id='Ext-data-Store-event-metachange'>            /**
</span>             * @event metachange
             * Fires when this store's reader provides new metadata (fields). This is currently only supported for JsonReaders.
             * @param {Store} this
             * @param {Object} meta The JSON metadata
             */
            'metachange',
<span id='Ext-data-Store-event-add'>            /**
</span>             * @event add
             * Fires when Records have been {@link #add}ed to the Store
             * @param {Store} this
             * @param {Ext.data.Record[]} records The array of Records added
             * @param {Number} index The index at which the record(s) were added
             */
            'add',
<span id='Ext-data-Store-event-remove'>            /**
</span>             * @event remove
             * Fires when a Record has been {@link #remove}d from the Store
             * @param {Store} this
             * @param {Ext.data.Record} record The Record that was removed
             * @param {Number} index The index at which the record was removed
             */
            'remove',
<span id='Ext-data-Store-event-update'>            /**
</span>             * @event update
             * Fires when a Record has been updated
             * @param {Store} this
             * @param {Ext.data.Record} record The Record that was updated
             * @param {String} operation The update operation being performed.  Value may be one of:
             * &lt;pre&gt;&lt;code&gt;
     Ext.data.Record.EDIT
     Ext.data.Record.REJECT
     Ext.data.Record.COMMIT
             * &lt;/code&gt;&lt;/pre&gt;
             */
            'update',
<span id='Ext-data-Store-event-clear'>            /**
</span>             * @event clear
             * Fires when the data cache has been cleared.
             * @param {Store} this
             * @param {Record[]} records The records that were cleared.
             */
            'clear',
<span id='Ext-data-Store-event-exception'>            /**
</span>             * @event exception
             * &lt;p&gt;Fires if an exception occurs in the Proxy during a remote request.
             * This event is relayed through the corresponding {@link Ext.data.DataProxy}.
             * See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#exception exception}
             * for additional details.
             * @param {misc} misc See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#exception exception}
             * for description.
             */
            'exception',
<span id='Ext-data-Store-event-beforeload'>            /**
</span>             * @event beforeload
             * Fires before a request is made for a new data object.  If the beforeload handler returns
             * &lt;tt&gt;false&lt;/tt&gt; the {@link #load} action will be canceled.
             * @param {Store} this
             * @param {Object} options The loading options that were specified (see {@link #load} for details)
             */
            'beforeload',
<span id='Ext-data-Store-event-load'>            /**
</span>             * @event load
             * Fires after a new set of Records has been loaded.
             * @param {Store} this
             * @param {Ext.data.Record[]} records The Records that were loaded
             * @param {Object} options The loading options that were specified (see {@link #load} for details)
             */
            'load',
<span id='Ext-data-Store-event-loadexception'>            /**
</span>             * @event loadexception
             * &lt;p&gt;This event is &lt;b&gt;deprecated&lt;/b&gt; in favor of the catch-all &lt;b&gt;&lt;code&gt;{@link #exception}&lt;/code&gt;&lt;/b&gt;
             * event instead.&lt;/p&gt;
             * &lt;p&gt;This event is relayed through the corresponding {@link Ext.data.DataProxy}.
             * See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#loadexception loadexception}
             * for additional details.
             * @param {misc} misc See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#loadexception loadexception}
             * for description.
             */
            'loadexception',
<span id='Ext-data-Store-event-beforewrite'>            /**
</span>             * @event beforewrite
             * @param {Ext.data.Store} store
             * @param {String} action [Ext.data.Api.actions.create|update|destroy]
             * @param {Record/Record[]} rs The Record(s) being written.
             * @param {Object} options The loading options that were specified. Edit &lt;code&gt;options.params&lt;/code&gt; to add Http parameters to the request.  (see {@link #save} for details)
             * @param {Object} arg The callback's arg object passed to the {@link #request} function
             */
            'beforewrite',
<span id='Ext-data-Store-event-write'>            /**
</span>             * @event write
             * Fires if the server returns 200 after an Ext.data.Api.actions CRUD action.
             * Success of the action is determined in the &lt;code&gt;result['successProperty']&lt;/code&gt;property (&lt;b&gt;NOTE&lt;/b&gt; for RESTful stores,
             * a simple 20x response is sufficient for the actions &quot;destroy&quot; and &quot;update&quot;.  The &quot;create&quot; action should should return 200 along with a database pk).
             * @param {Ext.data.Store} store
             * @param {String} action [Ext.data.Api.actions.create|update|destroy]
             * @param {Object} result The 'data' picked-out out of the response for convenience.
             * @param {Ext.Direct.Transaction} res
             * @param {Record/Record[]} rs Store's records, the subject(s) of the write-action
             */
            'write',
<span id='Ext-data-Store-event-beforesave'>            /**
</span>             * @event beforesave
             * Fires before a save action is called. A save encompasses destroying records, updating records and creating records.
             * @param {Ext.data.Store} store
             * @param {Object} data An object containing the data that is to be saved. The object will contain a key for each appropriate action,
             * with an array of records for each action.
             */
            'beforesave',
<span id='Ext-data-Store-event-save'>            /**
</span>             * @event save
             * Fires after a save is completed. A save encompasses destroying records, updating records and creating records.
             * @param {Ext.data.Store} store
             * @param {Number} batch The identifier for the batch that was saved.
             * @param {Object} data An object containing the data that is to be saved. The object will contain a key for each appropriate action,
             * with an array of records for each action.
             */
            'save'

        );

        if(this.proxy){
            // TODO remove deprecated loadexception with ext-3.0.1
            this.relayEvents(this.proxy,  ['loadexception', 'exception']);
        }
        // With a writer set for the Store, we want to listen to add/remove events to remotely create/destroy records.
        if (this.writer) {
            this.on({
                scope: this,
                add: this.createRecords,
                remove: this.destroyRecord,
                update: this.updateRecord,
                clear: this.onClear
            });
        }

        this.sortToggle = {};
        if(this.sortField){
            this.setDefaultSort(this.sortField, this.sortDir);
        }else if(this.sortInfo){
            this.setDefaultSort(this.sortInfo.field, this.sortInfo.direction);
        }

        Ext.data.Store.superclass.constructor.call(this);

        if(this.id){
            this.storeId = this.id;
            delete this.id;
        }
        if(this.storeId){
            Ext.StoreMgr.register(this);
        }
        if(this.inlineData){
            this.loadData(this.inlineData);
            delete this.inlineData;
        }else if(this.autoLoad){
            this.load.defer(10, this, [
                typeof this.autoLoad == 'object' ?
                    this.autoLoad : undefined]);
        }
        // used internally to uniquely identify a batch
        this.batchCounter = 0;
        this.batches = {};
    },

<span id='Ext-data-Store-method-buildWriter'>    /**
</span>     * builds a DataWriter instance when Store constructor is provided with a writer config-object instead of an instace.
     * @param {Object} config Writer configuration
     * @return {Ext.data.DataWriter}
     * @private
     */
    buildWriter : function(config) {
        var klass = undefined,
            type = (config.format || 'json').toLowerCase();
        switch (type) {
            case 'json':
                klass = Ext.data.JsonWriter;
                break;
            case 'xml':
                klass = Ext.data.XmlWriter;
                break;
            default:
                klass = Ext.data.JsonWriter;
        }
        return new klass(config);
    },

<span id='Ext-data-Store-method-destroy'>    /**
</span>     * Destroys the store.
     */
    destroy : function(){
        if(!this.isDestroyed){
            if(this.storeId){
                Ext.StoreMgr.unregister(this);
            }
            this.clearData();
            this.data = null;
            Ext.destroy(this.proxy);
            this.reader = this.writer = null;
            this.purgeListeners();
            this.isDestroyed = true;
        }
    },

<span id='Ext-data-Store-method-add'>    /**
</span>     * Add Records to the Store and fires the {@link #add} event.  To add Records
     * to the store from a remote source use &lt;code&gt;{@link #load}({add:true})&lt;/code&gt;.
     * See also &lt;code&gt;{@link #recordType}&lt;/code&gt; and &lt;code&gt;{@link #insert}&lt;/code&gt;.
     * @param {Ext.data.Record[]} records An Array of Ext.data.Record objects
     * to add to the cache. See {@link #recordType}.
     */
    add : function(records) {
        var i, len, record, index;

        records = [].concat(records);
        if (records.length &lt; 1) {
            return;
        }

        for (i = 0, len = records.length; i &lt; len; i++) {
            record = records[i];

            record.join(this);

            if (record.dirty || record.phantom) {
                this.modified.push(record);
            }
        }

        index = this.data.length;
        this.data.addAll(records);

        if (this.snapshot) {
            this.snapshot.addAll(records);
        }

        this.fireEvent('add', this, records, index);
    },

<span id='Ext-data-Store-method-addSorted'>    /**
</span>     * (Local sort only) Inserts the passed Record into the Store at the index where it
     * should go based on the current sort information.
     * @param {Ext.data.Record} record
     */
    addSorted : function(record){
        var index = this.findInsertIndex(record);
        this.insert(index, record);
    },

<span id='Ext-data-Store-method-doUpdate'>    /**
</span>     * @private
     * Update a record within the store with a new reference
     */
    doUpdate: function(rec){
        var id = rec.id;
        // unjoin the old record
        this.getById(id).join(null);

        this.data.replace(id, rec);
        if (this.snapshot) {
            this.snapshot.replace(id, rec);
        }
        rec.join(this);
        this.fireEvent('update', this, rec, Ext.data.Record.COMMIT);
    },

<span id='Ext-data-Store-method-remove'>    /**
</span>     * Remove Records from the Store and fires the {@link #remove} event.
     * @param {Ext.data.Record/Ext.data.Record[]} record The record object or array of records to remove from the cache.
     */
    remove : function(record){
        if(Ext.isArray(record)){
            Ext.each(record, function(r){
                this.remove(r);
            }, this);
            return;
        }
        var index = this.data.indexOf(record);
        if(index &gt; -1){
            record.join(null);
            this.data.removeAt(index);
        }
        if(this.pruneModifiedRecords){
            this.modified.remove(record);
        }
        if(this.snapshot){
            this.snapshot.remove(record);
        }
        if(index &gt; -1){
            this.fireEvent('remove', this, record, index);
        }
    },

<span id='Ext-data-Store-method-removeAt'>    /**
</span>     * Remove a Record from the Store at the specified index. Fires the {@link #remove} event.
     * @param {Number} index The index of the record to remove.
     */
    removeAt : function(index){
        this.remove(this.getAt(index));
    },

<span id='Ext-data-Store-method-removeAll'>    /**
</span>     * Remove all Records from the Store and fires the {@link #clear} event.
     * @param {Boolean} silent [false] Defaults to &lt;tt&gt;false&lt;/tt&gt;.  Set &lt;tt&gt;true&lt;/tt&gt; to not fire clear event.
     */
    removeAll : function(silent){
        var items = [];
        this.each(function(rec){
            items.push(rec);
        });
        this.clearData();
        if(this.snapshot){
            this.snapshot.clear();
        }
        if(this.pruneModifiedRecords){
            this.modified = [];
        }
        if (silent !== true) {  // &lt;-- prevents write-actions when we just want to clear a store.
            this.fireEvent('clear', this, items);
        }
    },

<span id='Ext-data-Store-method-onClear'>    // private
</span>    onClear: function(store, records){
        Ext.each(records, function(rec, index){
            this.destroyRecord(this, rec, index);
        }, this);
    },

<span id='Ext-data-Store-method-insert'>    /**
</span>     * Inserts Records into the Store at the given index and fires the {@link #add} event.
     * See also &lt;code&gt;{@link #add}&lt;/code&gt; and &lt;code&gt;{@link #addSorted}&lt;/code&gt;.
     * @param {Number} index The start index at which to insert the passed Records.
     * @param {Ext.data.Record[]} records An Array of Ext.data.Record objects to add to the cache.
     */
    insert : function(index, records) {
        var i, len, record;

        records = [].concat(records);
        for (i = 0, len = records.length; i &lt; len; i++) {
            record = records[i];

            this.data.insert(index + i, record);
            record.join(this);

            if (record.dirty || record.phantom) {
                this.modified.push(record);
            }
        }

        if (this.snapshot) {
            this.snapshot.addAll(records);
        }

        this.fireEvent('add', this, records, index);
    },

<span id='Ext-data-Store-method-indexOf'>    /**
</span>     * Get the index within the cache of the passed Record.
     * @param {Ext.data.Record} record The Ext.data.Record object to find.
     * @return {Number} The index of the passed Record. Returns -1 if not found.
     */
    indexOf : function(record){
        return this.data.indexOf(record);
    },

<span id='Ext-data-Store-method-indexOfId'>    /**
</span>     * Get the index within the cache of the Record with the passed id.
     * @param {String} id The id of the Record to find.
     * @return {Number} The index of the Record. Returns -1 if not found.
     */
    indexOfId : function(id){
        return this.data.indexOfKey(id);
    },

<span id='Ext-data-Store-method-getById'>    /**
</span>     * Get the Record with the specified id.
     * @param {String} id The id of the Record to find.
     * @return {Ext.data.Record} The Record with the passed id. Returns undefined if not found.
     */
    getById : function(id){
        return (this.snapshot || this.data).key(id);
    },

<span id='Ext-data-Store-method-getAt'>    /**
</span>     * Get the Record at the specified index.
     * @param {Number} index The index of the Record to find.
     * @return {Ext.data.Record} The Record at the passed index. Returns undefined if not found.
     */
    getAt : function(index){
        return this.data.itemAt(index);
    },

<span id='Ext-data-Store-method-getRange'>    /**
</span>     * Returns a range of Records between specified indices.
     * @param {Number} startIndex (optional) The starting index (defaults to 0)
     * @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store)
     * @return {Ext.data.Record[]} An array of Records
     */
    getRange : function(start, end){
        return this.data.getRange(start, end);
    },

<span id='Ext-data-Store-method-storeOptions'>    // private
</span>    storeOptions : function(o){
        o = Ext.apply({}, o);
        delete o.callback;
        delete o.scope;
        this.lastOptions = o;
    },

<span id='Ext-data-Store-method-clearData'>    // private
</span>    clearData: function(){
        this.data.each(function(rec) {
            rec.join(null);
        });
        this.data.clear();
    },

<span id='Ext-data-Store-method-load'>    /**
</span>     * &lt;p&gt;Loads the Record cache from the configured &lt;tt&gt;{@link #proxy}&lt;/tt&gt; using the configured &lt;tt&gt;{@link #reader}&lt;/tt&gt;.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;Notes:&lt;/p&gt;&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;u&gt;Important&lt;/u&gt;&lt;/b&gt;: loading is asynchronous! This call will return before the new data has been
     * loaded. To perform any post-processing where information from the load call is required, specify
     * the &lt;tt&gt;callback&lt;/tt&gt; function to be called, or use a {@link Ext.util.Observable#listeners a 'load' event handler}.&lt;/li&gt;
     * &lt;li&gt;If using {@link Ext.PagingToolbar remote paging}, the first load call must specify the &lt;tt&gt;start&lt;/tt&gt; and &lt;tt&gt;limit&lt;/tt&gt;
     * properties in the &lt;code&gt;options.params&lt;/code&gt; property to establish the initial position within the
     * dataset, and the number of Records to cache on each read from the Proxy.&lt;/li&gt;
     * &lt;li&gt;If using {@link #remoteSort remote sorting}, the configured &lt;code&gt;{@link #sortInfo}&lt;/code&gt;
     * will be automatically included with the posted parameters according to the specified
     * &lt;code&gt;{@link #paramNames}&lt;/code&gt;.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @param {Object} options An object containing properties which control loading options:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;params&lt;/tt&gt;&lt;/b&gt; :Object&lt;div class=&quot;sub-desc&quot;&gt;&lt;p&gt;An object containing properties to pass as HTTP
     * parameters to a remote data source. &lt;b&gt;Note&lt;/b&gt;: &lt;code&gt;params&lt;/code&gt; will override any
     * &lt;code&gt;{@link #baseParams}&lt;/code&gt; of the same name.&lt;/p&gt;
     * &lt;p&gt;Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;callback&lt;/b&gt; : Function&lt;div class=&quot;sub-desc&quot;&gt;&lt;p&gt;A function to be called after the Records
     * have been loaded. The callback is called after the load event is fired, and is passed the following arguments:&lt;ul&gt;
     * &lt;li&gt;r : Ext.data.Record[] An Array of Records loaded.&lt;/li&gt;
     * &lt;li&gt;options : Options object from the load call.&lt;/li&gt;
     * &lt;li&gt;success : Boolean success indicator.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;scope&lt;/b&gt; : Object&lt;div class=&quot;sub-desc&quot;&gt;&lt;p&gt;Scope with which to call the callback (defaults
     * to the Store object)&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;add&lt;/b&gt; : Boolean&lt;div class=&quot;sub-desc&quot;&gt;&lt;p&gt;Indicator to append loaded records rather than
     * replace the current cache.  &lt;b&gt;Note&lt;/b&gt;: see note for &lt;tt&gt;{@link #loadData}&lt;/tt&gt;&lt;/p&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @return {Boolean} If the &lt;i&gt;developer&lt;/i&gt; provided &lt;tt&gt;{@link #beforeload}&lt;/tt&gt; event handler returns
     * &lt;tt&gt;false&lt;/tt&gt;, the load call will abort and will return &lt;tt&gt;false&lt;/tt&gt;; otherwise will return &lt;tt&gt;true&lt;/tt&gt;.
     */
    load : function(options) {
        options = Ext.apply({}, options);
        this.storeOptions(options);
        if(this.sortInfo &amp;&amp; this.remoteSort){
            var pn = this.paramNames;
            options.params = Ext.apply({}, options.params);
            options.params[pn.sort] = this.sortInfo.field;
            options.params[pn.dir] = this.sortInfo.direction;
        }
        try {
            return this.execute('read', null, options); // &lt;-- null represents rs.  No rs for load actions.
        } catch(e) {
            this.handleException(e);
            return false;
        }
    },

<span id='Ext-data-Store-method-updateRecord'>    /**
</span>     * updateRecord  Should not be used directly.  This method will be called automatically if a Writer is set.
     * Listens to 'update' event.
     * @param {Object} store
     * @param {Object} record
     * @param {Object} action
     * @private
     */
    updateRecord : function(store, record, action) {
        if (action == Ext.data.Record.EDIT &amp;&amp; this.autoSave === true &amp;&amp; (!record.phantom || (record.phantom &amp;&amp; record.isValid()))) {
            this.save();
        }
    },

<span id='Ext-data-Store-method-createRecords'>    /**
</span>     * @private
     * Should not be used directly.  Store#add will call this automatically if a Writer is set
     * @param {Object} store
     * @param {Object} records
     * @param {Object} index
     */
    createRecords : function(store, records, index) {
        var modified = this.modified,
            length   = records.length,
            record, i;

        for (i = 0; i &lt; length; i++) {
            record = records[i];

            if (record.phantom &amp;&amp; record.isValid()) {
                record.markDirty();  // &lt;-- Mark new records dirty (Ed: why?)

                if (modified.indexOf(record) == -1) {
                    modified.push(record);
                }
            }
        }
        if (this.autoSave === true) {
            this.save();
        }
    },

<span id='Ext-data-Store-method-destroyRecord'>    /**
</span>     * Destroys a Record.  Should not be used directly.  It's called by Store#remove if a Writer is set.
     * @param {Store} store this
     * @param {Ext.data.Record} record
     * @param {Number} index
     * @private
     */
    destroyRecord : function(store, record, index) {
        if (this.modified.indexOf(record) != -1) {  // &lt;-- handled already if @cfg pruneModifiedRecords == true
            this.modified.remove(record);
        }
        if (!record.phantom) {
            this.removed.push(record);

            // since the record has already been removed from the store but the server request has not yet been executed,
            // must keep track of the last known index this record existed.  If a server error occurs, the record can be
            // put back into the store.  @see Store#createCallback where the record is returned when response status === false
            record.lastIndex = index;

            if (this.autoSave === true) {
                this.save();
            }
        }
    },

<span id='Ext-data-Store-method-execute'>    /**
</span>     * This method should generally not be used directly.  This method is called internally
     * by {@link #load}, or if a Writer is set will be called automatically when {@link #add},
     * {@link #remove}, or {@link #update} events fire.
     * @param {String} action Action name ('read', 'create', 'update', or 'destroy')
     * @param {Record/Record[]} rs
     * @param {Object} options
     * @throws Error
     * @private
     */
    execute : function(action, rs, options, /* private */ batch) {
        // blow up if action not Ext.data.CREATE, READ, UPDATE, DESTROY
        if (!Ext.data.Api.isAction(action)) {
            throw new Ext.data.Api.Error('execute', action);
        }
        // make sure options has a fresh, new params hash
        options = Ext.applyIf(options||{}, {
            params: {}
        });
        if(batch !== undefined){
            this.addToBatch(batch);
        }
        // have to separate before-events since load has a different signature than create,destroy and save events since load does not
        // include the rs (record resultset) parameter.  Capture return values from the beforeaction into doRequest flag.
        var doRequest = true;

        if (action === 'read') {
            doRequest = this.fireEvent('beforeload', this, options);
            Ext.applyIf(options.params, this.baseParams);
        }
        else {
            // if Writer is configured as listful, force single-record rs to be [{}] instead of {}
            // TODO Move listful rendering into DataWriter where the @cfg is defined.  Should be easy now.
            if (this.writer.listful === true &amp;&amp; this.restful !== true) {
                rs = (Ext.isArray(rs)) ? rs : [rs];
            }
            // if rs has just a single record, shift it off so that Writer writes data as '{}' rather than '[{}]'
            else if (Ext.isArray(rs) &amp;&amp; rs.length == 1) {
                rs = rs.shift();
            }
            // Write the action to options.params
            if ((doRequest = this.fireEvent('beforewrite', this, action, rs, options)) !== false) {
                this.writer.apply(options.params, this.baseParams, action, rs);
            }
        }
        if (doRequest !== false) {
            // Send request to proxy.
            if (this.writer &amp;&amp; this.proxy.url &amp;&amp; !this.proxy.restful &amp;&amp; !Ext.data.Api.hasUniqueUrl(this.proxy, action)) {
                options.params.xaction = action;    // &lt;-- really old, probaby unecessary.
            }
            // Note:  Up until this point we've been dealing with 'action' as a key from Ext.data.Api.actions.
            // We'll flip it now and send the value into DataProxy#request, since it's the value which maps to
            // the user's configured DataProxy#api
            // TODO Refactor all Proxies to accept an instance of Ext.data.Request (not yet defined) instead of this looooooong list
            // of params.  This method is an artifact from Ext2.
            this.proxy.request(Ext.data.Api.actions[action], rs, options.params, this.reader, this.createCallback(action, rs, batch), this, options);
        }
        return doRequest;
    },

<span id='Ext-data-Store-method-save'>    /**
</span>     * Saves all pending changes to the store.  If the commensurate Ext.data.Api.actions action is not configured, then
     * the configured &lt;code&gt;{@link #url}&lt;/code&gt; will be used.
     * &lt;pre&gt;
     * change            url
     * ---------------   --------------------
     * removed records   Ext.data.Api.actions.destroy
     * phantom records   Ext.data.Api.actions.create
     * {@link #getModifiedRecords modified records}  Ext.data.Api.actions.update
     * &lt;/pre&gt;
     * @TODO:  Create extensions of Error class and send associated Record with thrown exceptions.
     * e.g.:  Ext.data.DataReader.Error or Ext.data.Error or Ext.data.DataProxy.Error, etc.
     * @return {Number} batch Returns a number to uniquely identify the &quot;batch&quot; of saves occurring. -1 will be returned
     * if there are no items to save or the save was cancelled.
     */
    save : function() {
        if (!this.writer) {
            throw new Ext.data.Store.Error('writer-undefined');
        }

        var queue = [],
            len,
            trans,
            batch,
            data = {},
            i;
        // DESTROY:  First check for removed records.  Records in this.removed are guaranteed non-phantoms.  @see Store#remove
        if(this.removed.length){
            queue.push(['destroy', this.removed]);
        }

        // Check for modified records. Use a copy so Store#rejectChanges will work if server returns error.
        var rs = [].concat(this.getModifiedRecords());
        if(rs.length){
            // CREATE:  Next check for phantoms within rs.  splice-off and execute create.
            var phantoms = [];
            for(i = rs.length-1; i &gt;= 0; i--){
                if(rs[i].phantom === true){
                    var rec = rs.splice(i, 1).shift();
                    if(rec.isValid()){
                        phantoms.push(rec);
                    }
                }else if(!rs[i].isValid()){ // &lt;-- while we're here, splice-off any !isValid real records
                    rs.splice(i,1);
                }
            }
            // If we have valid phantoms, create them...
            if(phantoms.length){
                queue.push(['create', phantoms]);
            }

            // UPDATE:  And finally, if we're still here after splicing-off phantoms and !isValid real records, update the rest...
            if(rs.length){
                queue.push(['update', rs]);
            }
        }
        len = queue.length;
        if(len){
            batch = ++this.batchCounter;
            for(i = 0; i &lt; len; ++i){
                trans = queue[i];
                data[trans[0]] = trans[1];
            }
            if(this.fireEvent('beforesave', this, data) !== false){
                for(i = 0; i &lt; len; ++i){
                    trans = queue[i];
                    this.doTransaction(trans[0], trans[1], batch);
                }
                return batch;
            }
        }
        return -1;
    },

<span id='Ext-data-Store-method-doTransaction'>    // private.  Simply wraps call to Store#execute in try/catch.  Defers to Store#handleException on error.  Loops if batch: false
</span>    doTransaction : function(action, rs, batch) {
        function transaction(records) {
            try{
                this.execute(action, records, undefined, batch);
            }catch (e){
                this.handleException(e);
            }
        }
        if(this.batch === false){
            for(var i = 0, len = rs.length; i &lt; len; i++){
                transaction.call(this, rs[i]);
            }
        }else{
            transaction.call(this, rs);
        }
    },

<span id='Ext-data-Store-method-addToBatch'>    // private
</span>    addToBatch : function(batch){
        var b = this.batches,
            key = this.batchKey + batch,
            o = b[key];

        if(!o){
            b[key] = o = {
                id: batch,
                count: 0,
                data: {}
            };
        }
        ++o.count;
    },

<span id='Ext-data-Store-method-removeFromBatch'>    removeFromBatch : function(batch, action, data){
</span>        var b = this.batches,
            key = this.batchKey + batch,
            o = b[key],
            arr;


        if(o){
            arr = o.data[action] || [];
            o.data[action] = arr.concat(data);
            if(o.count === 1){
                data = o.data;
                delete b[key];
                this.fireEvent('save', this, batch, data);
            }else{
                --o.count;
            }
        }
    },

<span id='Ext-data-Store-method-createCallback'>    // @private callback-handler for remote CRUD actions
</span>    // Do not override -- override loadRecords, onCreateRecords, onDestroyRecords and onUpdateRecords instead.
    createCallback : function(action, rs, batch) {
        var actions = Ext.data.Api.actions;
        return (action == 'read') ? this.loadRecords : function(data, response, success) {
            // calls: onCreateRecords | onUpdateRecords | onDestroyRecords
            this['on' + Ext.util.Format.capitalize(action) + 'Records'](success, rs, [].concat(data));
            // If success === false here, exception will have been called in DataProxy
            if (success === true) {
                this.fireEvent('write', this, action, data, response, rs);
            }
            this.removeFromBatch(batch, action, data);
        };
    },

<span id='Ext-data-Store-method-clearModified'>    // Clears records from modified array after an exception event.
</span>    // NOTE:  records are left marked dirty.  Do we want to commit them even though they were not updated/realized?
    // TODO remove this method?
    clearModified : function(rs) {
        if (Ext.isArray(rs)) {
            for (var n=rs.length-1;n&gt;=0;n--) {
                this.modified.splice(this.modified.indexOf(rs[n]), 1);
            }
        } else {
            this.modified.splice(this.modified.indexOf(rs), 1);
        }
    },

<span id='Ext-data-Store-method-reMap'>    // remap record ids in MixedCollection after records have been realized.  @see Store#onCreateRecords, @see DataReader#realize
</span>    reMap : function(record) {
        if (Ext.isArray(record)) {
            for (var i = 0, len = record.length; i &lt; len; i++) {
                this.reMap(record[i]);
            }
        } else {
            delete this.data.map[record._phid];
            this.data.map[record.id] = record;
            var index = this.data.keys.indexOf(record._phid);
            this.data.keys.splice(index, 1, record.id);
            delete record._phid;
        }
    },

<span id='Ext-data-Store-method-onCreateRecords'>    // @protected onCreateRecord proxy callback for create action
</span>    onCreateRecords : function(success, rs, data) {
        if (success === true) {
            try {
                this.reader.realize(rs, data);
            }
            catch (e) {
                this.handleException(e);
                if (Ext.isArray(rs)) {
                    // Recurse to run back into the try {}.  DataReader#realize splices-off the rs until empty.
                    this.onCreateRecords(success, rs, data);
                }
            }
        }
    },

<span id='Ext-data-Store-method-onUpdateRecords'>    // @protected, onUpdateRecords proxy callback for update action
</span>    onUpdateRecords : function(success, rs, data) {
        if (success === true) {
            try {
                this.reader.update(rs, data);
            } catch (e) {
                this.handleException(e);
                if (Ext.isArray(rs)) {
                    // Recurse to run back into the try {}.  DataReader#update splices-off the rs until empty.
                    this.onUpdateRecords(success, rs, data);
                }
            }
        }
    },

<span id='Ext-data-Store-method-onDestroyRecords'>    // @protected onDestroyRecords proxy callback for destroy action
</span>    onDestroyRecords : function(success, rs, data) {
        // splice each rec out of this.removed
        rs = (rs instanceof Ext.data.Record) ? [rs] : [].concat(rs);
        for (var i=0,len=rs.length;i&lt;len;i++) {
            this.removed.splice(this.removed.indexOf(rs[i]), 1);
        }
        if (success === false) {
            // put records back into store if remote destroy fails.
            // @TODO: Might want to let developer decide.
            for (i=rs.length-1;i&gt;=0;i--) {
                this.insert(rs[i].lastIndex, rs[i]);    // &lt;-- lastIndex set in Store#destroyRecord
            }
        }
    },

<span id='Ext-data-Store-method-handleException'>    // protected handleException.  Possibly temporary until Ext framework has an exception-handler.
</span>    handleException : function(e) {
        // @see core/Error.js
        Ext.handleError(e);
    },

<span id='Ext-data-Store-method-reload'>    /**
</span>     * &lt;p&gt;Reloads the Record cache from the configured Proxy using the configured
     * {@link Ext.data.Reader Reader} and the options from the last load operation
     * performed.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: see the Important note in {@link #load}.&lt;/p&gt;
     * @param {Object} options &lt;p&gt;(optional) An &lt;tt&gt;Object&lt;/tt&gt; containing
     * {@link #load loading options} which may override the {@link #lastOptions options}
     * used in the last {@link #load} operation. See {@link #load} for details
     * (defaults to &lt;tt&gt;null&lt;/tt&gt;, in which case the {@link #lastOptions} are
     * used).&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;To add new params to the existing params:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
lastOptions = myStore.lastOptions;
Ext.apply(lastOptions.params, {
    myNewParam: true
});
myStore.reload(lastOptions);
     * &lt;/code&gt;&lt;/pre&gt;
     */
    reload : function(options){
        this.load(Ext.applyIf(options||{}, this.lastOptions));
    },

<span id='Ext-data-Store-method-loadRecords'>    // private
</span>    // Called as a callback by the Reader during a load operation.
    loadRecords : function(o, options, success){
        var i, len;

        if (this.isDestroyed === true) {
            return;
        }
        if(!o || success === false){
            if(success !== false){
                this.fireEvent('load', this, [], options);
            }
            if(options.callback){
                options.callback.call(options.scope || this, [], options, false, o);
            }
            return;
        }
        var r = o.records, t = o.totalRecords || r.length;
        if(!options || options.add !== true){
            if(this.pruneModifiedRecords){
                this.modified = [];
            }
            for(i = 0, len = r.length; i &lt; len; i++){
                r[i].join(this);
            }
            if(this.snapshot){
                this.data = this.snapshot;
                delete this.snapshot;
            }
            this.clearData();
            this.data.addAll(r);
            this.totalLength = t;
            this.applySort();
            this.fireEvent('datachanged', this);
        }else{
            var toAdd = [],
                rec,
                cnt = 0;
            for(i = 0, len = r.length; i &lt; len; ++i){
                rec = r[i];
                if(this.indexOfId(rec.id) &gt; -1){
                    this.doUpdate(rec);
                }else{
                    toAdd.push(rec);
                    ++cnt;
                }
            }
            this.totalLength = Math.max(t, this.data.length + cnt);
            this.add(toAdd);
        }
        this.fireEvent('load', this, r, options);
        if(options.callback){
            options.callback.call(options.scope || this, r, options, true);
        }
    },

<span id='Ext-data-Store-method-loadData'>    /**
</span>     * Loads data from a passed data block and fires the {@link #load} event. A {@link Ext.data.Reader Reader}
     * which understands the format of the data must have been configured in the constructor.
     * @param {Object} data The data block from which to read the Records.  The format of the data expected
     * is dependent on the type of {@link Ext.data.Reader Reader} that is configured and should correspond to
     * that {@link Ext.data.Reader Reader}'s &lt;tt&gt;{@link Ext.data.Reader#readRecords}&lt;/tt&gt; parameter.
     * @param {Boolean} append (Optional) &lt;tt&gt;true&lt;/tt&gt; to append the new Records rather the default to replace
     * the existing cache.
     * &lt;b&gt;Note&lt;/b&gt;: that Records in a Store are keyed by their {@link Ext.data.Record#id id}, so added Records
     * with ids which are already present in the Store will &lt;i&gt;replace&lt;/i&gt; existing Records. Only Records with
     * new, unique ids will be added.
     */
    loadData : function(o, append){
        var r = this.reader.readRecords(o);
        this.loadRecords(r, {add: append}, true);
    },

<span id='Ext-data-Store-method-getCount'>    /**
</span>     * Gets the number of cached records.
     * &lt;p&gt;If using paging, this may not be the total size of the dataset. If the data object
     * used by the Reader contains the dataset size, then the {@link #getTotalCount} function returns
     * the dataset size.  &lt;b&gt;Note&lt;/b&gt;: see the Important note in {@link #load}.&lt;/p&gt;
     * @return {Number} The number of Records in the Store's cache.
     */
    getCount : function(){
        return this.data.length || 0;
    },

<span id='Ext-data-Store-method-getTotalCount'>    /**
</span>     * Gets the total number of records in the dataset as returned by the server.
     * &lt;p&gt;If using paging, for this to be accurate, the data object used by the {@link #reader Reader}
     * must contain the dataset size. For remote data sources, the value for this property
     * (&lt;tt&gt;totalProperty&lt;/tt&gt; for {@link Ext.data.JsonReader JsonReader},
     * &lt;tt&gt;totalRecords&lt;/tt&gt; for {@link Ext.data.XmlReader XmlReader}) shall be returned by a query on the server.
     * &lt;b&gt;Note&lt;/b&gt;: see the Important note in {@link #load}.&lt;/p&gt;
     * @return {Number} The number of Records as specified in the data object passed to the Reader
     * by the Proxy.
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: this value is not updated when changing the contents of the Store locally.&lt;/p&gt;
     */
    getTotalCount : function(){
        return this.totalLength || 0;
    },

<span id='Ext-data-Store-method-getSortState'>    /**
</span>     * Returns an object describing the current sort state of this Store.
     * @return {Object} The sort state of the Store. An object with two properties:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;field : String&lt;/b&gt;&lt;p class=&quot;sub-desc&quot;&gt;The name of the field by which the Records are sorted.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;direction : String&lt;/b&gt;&lt;p class=&quot;sub-desc&quot;&gt;The sort order, 'ASC' or 'DESC' (case-sensitive).&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * See &lt;tt&gt;{@link #sortInfo}&lt;/tt&gt; for additional details.
     */
    getSortState : function(){
        return this.sortInfo;
    },

<span id='Ext-data-Store-method-applySort'>    /**
</span>     * @private
     * Invokes sortData if we have sortInfo to sort on and are not sorting remotely
     */
    applySort : function(){
        if ((this.sortInfo || this.multiSortInfo) &amp;&amp; !this.remoteSort) {
            this.sortData();
        }
    },

<span id='Ext-data-Store-method-sortData'>    /**
</span>     * @private
     * Performs the actual sorting of data. This checks to see if we currently have a multi sort or not. It applies
     * each sorter field/direction pair in turn by building an OR'ed master sorting function and running it against
     * the full dataset
     */
    sortData : function() {
        var sortInfo  = this.hasMultiSort ? this.multiSortInfo : this.sortInfo,
            direction = sortInfo.direction || &quot;ASC&quot;,
            sorters   = sortInfo.sorters,
            sortFns   = [];

        //if we just have a single sorter, pretend it's the first in an array
        if (!this.hasMultiSort) {
            sorters = [{direction: direction, field: sortInfo.field}];
        }

        //create a sorter function for each sorter field/direction combo
        for (var i=0, j = sorters.length; i &lt; j; i++) {
            sortFns.push(this.createSortFunction(sorters[i].field, sorters[i].direction));
        }

        if (sortFns.length == 0) {
            return;
        }

        //the direction modifier is multiplied with the result of the sorting functions to provide overall sort direction
        //(as opposed to direction per field)
        var directionModifier = direction.toUpperCase() == &quot;DESC&quot; ? -1 : 1;

        //create a function which ORs each sorter together to enable multi-sort
        var fn = function(r1, r2) {
          var result = sortFns[0].call(this, r1, r2);

          //if we have more than one sorter, OR any additional sorter functions together
          if (sortFns.length &gt; 1) {
              for (var i=1, j = sortFns.length; i &lt; j; i++) {
                  result = result || sortFns[i].call(this, r1, r2);
              }
          }

          return directionModifier * result;
        };

        //sort the data
        this.data.sort(direction, fn);
        if (this.snapshot &amp;&amp; this.snapshot != this.data) {
            this.snapshot.sort(direction, fn);
        }
    },

<span id='Ext-data-Store-method-createSortFunction'>    /**
</span>     * @private
     * Creates and returns a function which sorts an array by the given field and direction
     * @param {String} field The field to create the sorter for
     * @param {String} direction The direction to sort by (defaults to &quot;ASC&quot;)
     * @return {Function} A function which sorts by the field/direction combination provided
     */
    createSortFunction: function(field, direction) {
        direction = direction || &quot;ASC&quot;;
        var directionModifier = direction.toUpperCase() == &quot;DESC&quot; ? -1 : 1;

        var sortType = this.fields.get(field).sortType;

        //create a comparison function. Takes 2 records, returns 1 if record 1 is greater,
        //-1 if record 2 is greater or 0 if they are equal
        return function(r1, r2) {
            var v1 = sortType(r1.data[field]),
                v2 = sortType(r2.data[field]);

            return directionModifier * (v1 &gt; v2 ? 1 : (v1 &lt; v2 ? -1 : 0));
        };
    },

<span id='Ext-data-Store-method-setDefaultSort'>    /**
</span>     * Sets the default sort column and order to be used by the next {@link #load} operation.
     * @param {String} fieldName The name of the field to sort by.
     * @param {String} dir (optional) The sort order, 'ASC' or 'DESC' (case-sensitive, defaults to &lt;tt&gt;'ASC'&lt;/tt&gt;)
     */
    setDefaultSort : function(field, dir) {
        dir = dir ? dir.toUpperCase() : 'ASC';
        this.sortInfo = {field: field, direction: dir};
        this.sortToggle[field] = dir;
    },

<span id='Ext-data-Store-method-sort'>    /**
</span>     * Sort the Records.
     * If remote sorting is used, the sort is performed on the server, and the cache is reloaded. If local
     * sorting is used, the cache is sorted internally. See also {@link #remoteSort} and {@link #paramNames}.
     * This function accepts two call signatures - pass in a field name as the first argument to sort on a single
     * field, or pass in an array of sort configuration objects to sort by multiple fields.
     * Single sort example:
     * store.sort('name', 'ASC');
     * Multi sort example:
     * store.sort([
     *   {
     *     field    : 'name',
     *     direction: 'ASC'
     *   },
     *   {
     *     field    : 'salary',
     *     direction: 'DESC'
     *   }
     * ], 'ASC');
     * In this second form, the sort configs are applied in order, with later sorters sorting within earlier sorters' results.
     * For example, if two records with the same name are present they will also be sorted by salary if given the sort configs
     * above. Any number of sort configs can be added.
     * @param {String/Array} fieldName The name of the field to sort by, or an array of ordered sort configs
     * @param {String} dir (optional) The sort order, 'ASC' or 'DESC' (case-sensitive, defaults to &lt;tt&gt;'ASC'&lt;/tt&gt;)
     */
    sort : function(fieldName, dir) {
        if (Ext.isArray(arguments[0])) {
            return this.multiSort.call(this, fieldName, dir);
        } else {
            return this.singleSort(fieldName, dir);
        }
    },

<span id='Ext-data-Store-method-singleSort'>    /**
</span>     * Sorts the store contents by a single field and direction. This is called internally by {@link sort} and would
     * not usually be called manually
     * @param {String} fieldName The name of the field to sort by.
     * @param {String} dir (optional) The sort order, 'ASC' or 'DESC' (case-sensitive, defaults to &lt;tt&gt;'ASC'&lt;/tt&gt;)
     */
    singleSort: function(fieldName, dir) {
        var field = this.fields.get(fieldName);
        if (!field) {
            return false;
        }

        var name       = field.name,
            sortInfo   = this.sortInfo || null,
            sortToggle = this.sortToggle ? this.sortToggle[name] : null;

        if (!dir) {
            if (sortInfo &amp;&amp; sortInfo.field == name) { // toggle sort dir
                dir = (this.sortToggle[name] || 'ASC').toggle('ASC', 'DESC');
            } else {
                dir = field.sortDir;
            }
        }

        this.sortToggle[name] = dir;
        this.sortInfo = {field: name, direction: dir};
        this.hasMultiSort = false;

        if (this.remoteSort) {
            if (!this.load(this.lastOptions)) {
                if (sortToggle) {
                    this.sortToggle[name] = sortToggle;
                }
                if (sortInfo) {
                    this.sortInfo = sortInfo;
                }
            }
        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
        return true;
    },

<span id='Ext-data-Store-method-multiSort'>    /**
</span>     * Sorts the contents of this store by multiple field/direction sorters. This is called internally by {@link sort}
     * and would not usually be called manually.
     * Multi sorting only currently applies to local datasets - multiple sort data is not currently sent to a proxy
     * if remoteSort is used.
     * @param {Array} sorters Array of sorter objects (field and direction)
     * @param {String} direction Overall direction to sort the ordered results by (defaults to &quot;ASC&quot;)
     */
    multiSort: function(sorters, direction) {
        this.hasMultiSort = true;
        direction = direction || &quot;ASC&quot;;

        //toggle sort direction
        if (this.multiSortInfo &amp;&amp; direction == this.multiSortInfo.direction) {
            direction = direction.toggle(&quot;ASC&quot;, &quot;DESC&quot;);
        }

<span id='Ext-data-Store-property-multiSortInfo'>        /**
</span>         * Object containing overall sort direction and an ordered array of sorter configs used when sorting on multiple fields
         * @property multiSortInfo
         * @type Object
         */
        this.multiSortInfo = {
            sorters  : sorters,
            direction: direction
        };

        if (this.remoteSort) {
            this.singleSort(sorters[0].field, sorters[0].direction);

        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
    },

<span id='Ext-data-Store-method-each'>    /**
</span>     * Calls the specified function for each of the {@link Ext.data.Record Records} in the cache.
     * @param {Function} fn The function to call. The {@link Ext.data.Record Record} is passed as the first parameter.
     * Returning &lt;tt&gt;false&lt;/tt&gt; aborts and exits the iteration.
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed.
     * Defaults to the current {@link Ext.data.Record Record} in the iteration.
     */
    each : function(fn, scope){
        this.data.each(fn, scope);
    },

<span id='Ext-data-Store-method-getModifiedRecords'>    /**
</span>     * Gets all {@link Ext.data.Record records} modified since the last commit.  Modified records are
     * persisted across load operations (e.g., during paging). &lt;b&gt;Note&lt;/b&gt;: deleted records are not
     * included.  See also &lt;tt&gt;{@link #pruneModifiedRecords}&lt;/tt&gt; and
     * {@link Ext.data.Record}&lt;tt&gt;{@link Ext.data.Record#markDirty markDirty}.&lt;/tt&gt;.
     * @return {Ext.data.Record[]} An array of {@link Ext.data.Record Records} containing outstanding
     * modifications.  To obtain modified fields within a modified record see
     *{@link Ext.data.Record}&lt;tt&gt;{@link Ext.data.Record#modified modified}.&lt;/tt&gt;.
     */
    getModifiedRecords : function(){
        return this.modified;
    },

<span id='Ext-data-Store-method-sum'>    /**
</span>     * Sums the value of &lt;tt&gt;property&lt;/tt&gt; for each {@link Ext.data.Record record} between &lt;tt&gt;start&lt;/tt&gt;
     * and &lt;tt&gt;end&lt;/tt&gt; and returns the result.
     * @param {String} property A field in each record
     * @param {Number} start (optional) The record index to start at (defaults to &lt;tt&gt;0&lt;/tt&gt;)
     * @param {Number} end (optional) The last record index to include (defaults to length - 1)
     * @return {Number} The sum
     */
    sum : function(property, start, end){
        var rs = this.data.items, v = 0;
        start = start || 0;
        end = (end || end === 0) ? end : rs.length-1;

        for(var i = start; i &lt;= end; i++){
            v += (rs[i].data[property] || 0);
        }
        return v;
    },

<span id='Ext-data-Store-method-createFilterFn'>    /**
</span>     * @private
     * Returns a filter function used to test a the given property's value. Defers most of the work to
     * Ext.util.MixedCollection's createValueMatcher function
     * @param {String} property The property to create the filter function for
     * @param {String/RegExp} value The string/regex to compare the property value to
     * @param {Boolean} anyMatch True if we don't care if the filter value is not the full value (defaults to false)
     * @param {Boolean} caseSensitive True to create a case-sensitive regex (defaults to false)
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false. Ignored if anyMatch is true.
     */
    createFilterFn : function(property, value, anyMatch, caseSensitive, exactMatch){
        if(Ext.isEmpty(value, false)){
            return false;
        }
        value = this.data.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
        return function(r) {
            return value.test(r.data[property]);
        };
    },

<span id='Ext-data-Store-method-createMultipleFilterFn'>    /**
</span>     * @private
     * Given an array of filter functions (each with optional scope), constructs and returns a single function that returns
     * the result of all of the filters ANDed together
     * @param {Array} filters The array of filter objects (each object should contain an 'fn' and optional scope)
     * @return {Function} The multiple filter function
     */
    createMultipleFilterFn: function(filters) {
        return function(record) {
            var isMatch = true;

            for (var i=0, j = filters.length; i &lt; j; i++) {
                var filter = filters[i],
                    fn     = filter.fn,
                    scope  = filter.scope;

                isMatch = isMatch &amp;&amp; fn.call(scope, record);
            }

            return isMatch;
        };
    },

<span id='Ext-data-Store-method-filter'>    /**
</span>     * Filter the {@link Ext.data.Record records} by a specified property. Alternatively, pass an array of filter
     * options to filter by more than one property.
     * Single filter example:
     * store.filter('name', 'Ed', true, true); //finds all records containing the substring 'Ed'
     * Multiple filter example:
     * &lt;pre&gt;&lt;code&gt;
     * store.filter([
     *   {
     *     property     : 'name',
     *     value        : 'Ed',
     *     anyMatch     : true, //optional, defaults to true
     *     caseSensitive: true  //optional, defaults to true
     *   },
     *
     *   //filter functions can also be passed
     *   {
     *     fn   : function(record) {
     *       return record.get('age') == 24
     *     },
     *     scope: this
     *   }
     * ]);
     * &lt;/code&gt;&lt;/pre&gt;
     * @param {String|Array} field A field on your records, or an array containing multiple filter options
     * @param {String/RegExp} value Either a string that the field should begin with, or a RegExp to test
     * against the field.
     * @param {Boolean} anyMatch (optional) &lt;tt&gt;true&lt;/tt&gt; to match any part not just the beginning
     * @param {Boolean} caseSensitive (optional) &lt;tt&gt;true&lt;/tt&gt; for case sensitive comparison
     * @param {Boolean} exactMatch (optional) True to force exact match (^ and $ characters added to the regex). Defaults to false. Ignored if anyMatch is true.
     */
    filter : function(property, value, anyMatch, caseSensitive, exactMatch){
        var fn;
        //we can accept an array of filter objects, or a single filter object - normalize them here
        if (Ext.isObject(property)) {
            property = [property];
        }

        if (Ext.isArray(property)) {
            var filters = [];

            //normalize the filters passed into an array of filter functions
            for (var i=0, j = property.length; i &lt; j; i++) {
                var filter = property[i],
                    func   = filter.fn,
                    scope  = filter.scope || this;

                //if we weren't given a filter function, construct one now
                if (!Ext.isFunction(func)) {
                    func = this.createFilterFn(filter.property, filter.value, filter.anyMatch, filter.caseSensitive, filter.exactMatch);
                }

                filters.push({fn: func, scope: scope});
            }

            fn = this.createMultipleFilterFn(filters);
        } else {
            //classic single property filter
            fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
        }

        return fn ? this.filterBy(fn) : this.clearFilter();
    },

<span id='Ext-data-Store-method-filterBy'>    /**
</span>     * Filter by a function. The specified function will be called for each
     * Record in this Store. If the function returns &lt;tt&gt;true&lt;/tt&gt; the Record is included,
     * otherwise it is filtered out.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Record&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Record record}
     * to test for filtering. Access field values using {@link Ext.data.Record#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     */
    filterBy : function(fn, scope){
        this.snapshot = this.snapshot || this.data;
        this.data = this.queryBy(fn, scope || this);
        this.fireEvent('datachanged', this);
    },

<span id='Ext-data-Store-method-clearFilter'>    /**
</span>     * Revert to a view of the Record cache with no filtering applied.
     * @param {Boolean} suppressEvent If &lt;tt&gt;true&lt;/tt&gt; the filter is cleared silently without firing the
     * {@link #datachanged} event.
     */
    clearFilter : function(suppressEvent){
        if(this.isFiltered()){
            this.data = this.snapshot;
            delete this.snapshot;
            if(suppressEvent !== true){
                this.fireEvent('datachanged', this);
            }
        }
    },

<span id='Ext-data-Store-method-isFiltered'>    /**
</span>     * Returns true if this store is currently filtered
     * @return {Boolean}
     */
    isFiltered : function(){
        return !!this.snapshot &amp;&amp; this.snapshot != this.data;
    },

<span id='Ext-data-Store-method-query'>    /**
</span>     * Query the records by a specified property.
     * @param {String} field A field on your records
     * @param {String/RegExp} value Either a string that the field
     * should begin with, or a RegExp to test against the field.
     * @param {Boolean} anyMatch (optional) True to match any part not just the beginning
     * @param {Boolean} caseSensitive (optional) True for case sensitive comparison
     * @return {MixedCollection} Returns an Ext.util.MixedCollection of the matched records
     */
    query : function(property, value, anyMatch, caseSensitive){
        var fn = this.createFilterFn(property, value, anyMatch, caseSensitive);
        return fn ? this.queryBy(fn) : this.data.clone();
    },

<span id='Ext-data-Store-method-queryBy'>    /**
</span>     * Query the cached records in this Store using a filtering function. The specified function
     * will be called with each record in this Store. If the function returns &lt;tt&gt;true&lt;/tt&gt; the record is
     * included in the results.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Record&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Record record}
     * to test for filtering. Access field values using {@link Ext.data.Record#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     * @return {MixedCollection} Returns an Ext.util.MixedCollection of the matched records
     **/
    queryBy : function(fn, scope){
        var data = this.snapshot || this.data;
        return data.filterBy(fn, scope||this);
    },

<span id='Ext-data-Store-method-find'>    /**
</span>     * Finds the index of the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {String/RegExp} value Either a string that the field value
     * should begin with, or a RegExp to test against the field.
     * @param {Number} startIndex (optional) The index to start searching at
     * @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
     * @param {Boolean} caseSensitive (optional) True for case sensitive comparison
     * @return {Number} The matched index or -1
     */
    find : function(property, value, start, anyMatch, caseSensitive){
        var fn = this.createFilterFn(property, value, anyMatch, caseSensitive);
        return fn ? this.data.findIndexBy(fn, null, start) : -1;
    },

<span id='Ext-data-Store-method-findExact'>    /**
</span>     * Finds the index of the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {Mixed} value The value to match the field against.
     * @param {Number} startIndex (optional) The index to start searching at
     * @return {Number} The matched index or -1
     */
    findExact: function(property, value, start){
        return this.data.findIndexBy(function(rec){
            return rec.get(property) === value;
        }, this, start);
    },

<span id='Ext-data-Store-method-findBy'>    /**
</span>     * Find the index of the first matching Record in this Store by a function.
     * If the function returns &lt;tt&gt;true&lt;/tt&gt; it is considered a match.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Record&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Record record}
     * to test for filtering. Access field values using {@link Ext.data.Record#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     * @param {Number} startIndex (optional) The index to start searching at
     * @return {Number} The matched index or -1
     */
    findBy : function(fn, scope, start){
        return this.data.findIndexBy(fn, scope, start);
    },

<span id='Ext-data-Store-method-collect'>    /**
</span>     * Collects unique values for a particular dataIndex from this store.
     * @param {String} dataIndex The property to collect
     * @param {Boolean} allowNull (optional) Pass true to allow null, undefined or empty string values
     * @param {Boolean} bypassFilter (optional) Pass true to collect from all records, even ones which are filtered
     * @return {Array} An array of the unique values
     **/
    collect : function(dataIndex, allowNull, bypassFilter){
        var d = (bypassFilter === true &amp;&amp; this.snapshot) ?
                this.snapshot.items : this.data.items;
        var v, sv, r = [], l = {};
        for(var i = 0, len = d.length; i &lt; len; i++){
            v = d[i].data[dataIndex];
            sv = String(v);
            if((allowNull || !Ext.isEmpty(v)) &amp;&amp; !l[sv]){
                l[sv] = true;
                r[r.length] = v;
            }
        }
        return r;
    },

<span id='Ext-data-Store-method-afterEdit'>    // private
</span>    afterEdit : function(record){
        if(this.modified.indexOf(record) == -1){
            this.modified.push(record);
        }
        this.fireEvent('update', this, record, Ext.data.Record.EDIT);
    },

<span id='Ext-data-Store-method-afterReject'>    // private
</span>    afterReject : function(record){
        this.modified.remove(record);
        this.fireEvent('update', this, record, Ext.data.Record.REJECT);
    },

<span id='Ext-data-Store-method-afterCommit'>    // private
</span>    afterCommit : function(record){
        this.modified.remove(record);
        this.fireEvent('update', this, record, Ext.data.Record.COMMIT);
    },

<span id='Ext-data-Store-method-commitChanges'>    /**
</span>     * Commit all Records with {@link #getModifiedRecords outstanding changes}. To handle updates for changes,
     * subscribe to the Store's {@link #update update event}, and perform updating when the third parameter is
     * Ext.data.Record.COMMIT.
     */
    commitChanges : function(){
        var modified = this.modified.slice(0),
            length   = modified.length,
            i;

        for (i = 0; i &lt; length; i++){
            modified[i].commit();
        }

        this.modified = [];
        this.removed  = [];
    },

<span id='Ext-data-Store-method-rejectChanges'>    /**
</span>     * {@link Ext.data.Record#reject Reject} outstanding changes on all {@link #getModifiedRecords modified records}.
     */
    rejectChanges : function() {
        var modified = this.modified.slice(0),
            removed  = this.removed.slice(0).reverse(),
            mLength  = modified.length,
            rLength  = removed.length,
            i;

        for (i = 0; i &lt; mLength; i++) {
            modified[i].reject();
        }

        for (i = 0; i &lt; rLength; i++) {
            this.insert(removed[i].lastIndex || 0, removed[i]);
            removed[i].reject();
        }

        this.modified = [];
        this.removed  = [];
    },

<span id='Ext-data-Store-method-onMetaChange'>    // private
</span>    onMetaChange : function(meta){
        this.recordType = this.reader.recordType;
        this.fields = this.recordType.prototype.fields;
        delete this.snapshot;
        if(this.reader.meta.sortInfo){
            this.sortInfo = this.reader.meta.sortInfo;
        }else if(this.sortInfo  &amp;&amp; !this.fields.get(this.sortInfo.field)){
            delete this.sortInfo;
        }
        if(this.writer){
            this.writer.meta = this.reader.meta;
        }
        this.modified = [];
        this.fireEvent('metachange', this, this.reader.meta);
    },

<span id='Ext-data-Store-method-findInsertIndex'>    // private
</span>    findInsertIndex : function(record){
        this.suspendEvents();
        var data = this.data.clone();
        this.data.add(record);
        this.applySort();
        var index = this.data.indexOf(record);
        this.data = data;
        this.resumeEvents();
        return index;
    },

<span id='Ext-data-Store-method-setBaseParam'>    /**
</span>     * Set the value for a property name in this store's {@link #baseParams}.  Usage:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
myStore.setBaseParam('foo', {bar:3});
&lt;/code&gt;&lt;/pre&gt;
     * @param {String} name Name of the property to assign
     * @param {Mixed} value Value to assign the &lt;tt&gt;name&lt;/tt&gt;d property
     **/
    setBaseParam : function (name, value){
        this.baseParams = this.baseParams || {};
        this.baseParams[name] = value;
    }
});

Ext.reg('store', Ext.data.Store);

<span id='Ext-data-Store-Error'>/**
</span> * @class Ext.data.Store.Error
 * @extends Ext.Error
 * Store Error extension.
 * @param {String} name
 */
Ext.data.Store.Error = Ext.extend(Ext.Error, {
<span id='Ext-data-Store-Error-property-name'>    name: 'Ext.data.Store'
</span>});
Ext.apply(Ext.data.Store.Error.prototype, {
    lang: {
        'writer-undefined' : 'Attempted to execute a write-action without a DataWriter installed.'
    }
});
</pre>
</body>
</html>
