<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-ComboBox-method-constructor'><span id='Ext-form-ComboBox'>/**
</span></span> * @class Ext.form.ComboBox
 * @extends Ext.form.TriggerField
 * &lt;p&gt;A combobox control with support for autocomplete, remote-loading, paging and many other features.&lt;/p&gt;
 * &lt;p&gt;A ComboBox works in a similar manner to a traditional HTML &amp;lt;select&gt; field. The difference is
 * that to submit the {@link #valueField}, you must specify a {@link #hiddenName} to create a hidden input
 * field to hold the value of the valueField. The &lt;i&gt;{@link #displayField}&lt;/i&gt; is shown in the text field
 * which is named according to the {@link #name}.&lt;/p&gt;
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;Events&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;To do something when something in ComboBox is selected, configure the select event:&lt;pre&gt;&lt;code&gt;
var cb = new Ext.form.ComboBox({
    // all of your config options
    listeners:{
         scope: yourScope,
         'select': yourFunction
    }
});

// Alternatively, you can assign events after the object is created:
var cb = new Ext.form.ComboBox(yourOptions);
cb.on('select', yourFunction, yourScope);
 * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;ComboBox in Grid&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;If using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer}
 * will be needed to show the displayField when the editor is not active.  Set up the renderer manually, or implement
 * a reusable render, for example:&lt;pre&gt;&lt;code&gt;
// create reusable renderer
Ext.util.Format.comboRenderer = function(combo){
    return function(value){
        var record = combo.findRecord(combo.{@link #valueField}, value);
        return record ? record.get(combo.{@link #displayField}) : combo.{@link #valueNotFoundText};
    }
}

// create the combo instance
var combo = new Ext.form.ComboBox({
    {@link #typeAhead}: true,
    {@link #triggerAction}: 'all',
    {@link #lazyRender}:true,
    {@link #mode}: 'local',
    {@link #store}: new Ext.data.ArrayStore({
        id: 0,
        fields: [
            'myId',
            'displayText'
        ],
        data: [[1, 'item1'], [2, 'item2']]
    }),
    {@link #valueField}: 'myId',
    {@link #displayField}: 'displayText'
});

// snippet of column model used within grid
var cm = new Ext.grid.ColumnModel([{
       ...
    },{
       header: &quot;Some Header&quot;,
       dataIndex: 'whatever',
       width: 130,
       editor: combo, // specify reference to combo instance
       renderer: Ext.util.Format.comboRenderer(combo) // pass combo instance to reusable renderer
    },
    ...
]);
 * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;&lt;u&gt;Filtering&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;A ComboBox {@link #doQuery uses filtering itself}, for information about filtering the ComboBox
 * store manually see &lt;tt&gt;{@link #lastQuery}&lt;/tt&gt;.&lt;/p&gt;
 * @constructor
 * Create a new ComboBox.
 * @param {Object} config Configuration options
 * @xtype combo
 */
Ext.form.ComboBox = Ext.extend(Ext.form.TriggerField, {
<span id='Ext-form-ComboBox-cfg-transform'>    /**
</span>     * @cfg {Mixed} transform The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox.
     * Note that if you specify this and the combo is going to be in an {@link Ext.form.BasicForm} or
     * {@link Ext.form.FormPanel}, you must also set &lt;tt&gt;{@link #lazyRender} = true&lt;/tt&gt;.
     */
<span id='Ext-form-ComboBox-cfg-lazyRender'>    /**
</span>     * @cfg {Boolean} lazyRender &lt;tt&gt;true&lt;/tt&gt; to prevent the ComboBox from rendering until requested
     * (should always be used when rendering into an {@link Ext.Editor} (e.g. {@link Ext.grid.EditorGridPanel Grids}),
     * defaults to &lt;tt&gt;false&lt;/tt&gt;).
     */
<span id='Ext-form-ComboBox-cfg-autoCreate'>    /**
</span>     * @cfg {String/Object} autoCreate &lt;p&gt;A {@link Ext.DomHelper DomHelper} element spec, or &lt;tt&gt;true&lt;/tt&gt; for a default
     * element spec. Used to create the {@link Ext.Component#getEl Element} which will encapsulate this Component.
     * See &lt;tt&gt;{@link Ext.Component#autoEl autoEl}&lt;/tt&gt; for details.  Defaults to:&lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;{tag: &quot;input&quot;, type: &quot;text&quot;, size: &quot;24&quot;, autocomplete: &quot;off&quot;}&lt;/code&gt;&lt;/pre&gt;
     */
<span id='Ext-form-ComboBox-cfg-store'>    /**
</span>     * @cfg {Ext.data.Store/Array} store The data source to which this combo is bound (defaults to &lt;tt&gt;undefined&lt;/tt&gt;).
     * Acceptable values for this property are:
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;any {@link Ext.data.Store Store} subclass&lt;/b&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;an Array&lt;/b&gt; : Arrays will be converted to a {@link Ext.data.ArrayStore} internally,
     * automatically generating {@link Ext.data.Field#name field names} to work with all data components.
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;1-dimensional array&lt;/b&gt; : (e.g., &lt;tt&gt;['Foo','Bar']&lt;/tt&gt;)&lt;div class=&quot;sub-desc&quot;&gt;
     * A 1-dimensional array will automatically be expanded (each array item will be used for both the combo
     * {@link #valueField} and {@link #displayField})&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;2-dimensional array&lt;/b&gt; : (e.g., &lt;tt&gt;[['f','Foo'],['b','Bar']]&lt;/tt&gt;)&lt;div class=&quot;sub-desc&quot;&gt;
     * For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo
     * {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.
     * &lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
     * &lt;p&gt;See also &lt;tt&gt;{@link #mode}&lt;/tt&gt;.&lt;/p&gt;
     */
<span id='Ext-form-ComboBox-cfg-title'>    /**
</span>     * @cfg {String} title If supplied, a header element is created containing this text and added into the top of
     * the dropdown list (defaults to undefined, with no header element)
     */

<span id='Ext-form-ComboBox-property-defaultAutoCreate'>    // private
</span>    defaultAutoCreate : {tag: &quot;input&quot;, type: &quot;text&quot;, size: &quot;24&quot;, autocomplete: &quot;off&quot;},
<span id='Ext-form-ComboBox-cfg-listWidth'>    /**
</span>     * @cfg {Number} listWidth The width (used as a parameter to {@link Ext.Element#setWidth}) of the dropdown
     * list (defaults to the width of the ComboBox field).  See also &lt;tt&gt;{@link #minListWidth}&lt;/tt&gt;
     */
<span id='Ext-form-ComboBox-cfg-displayField'>    /**
</span>     * @cfg {String} displayField The underlying {@link Ext.data.Field#name data field name} to bind to this
     * ComboBox (defaults to undefined if &lt;tt&gt;{@link #mode} = 'remote'&lt;/tt&gt; or &lt;tt&gt;'field1'&lt;/tt&gt; if
     * {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on
     * the store configuration}).
     * &lt;p&gt;See also &lt;tt&gt;{@link #valueField}&lt;/tt&gt;.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: if using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a
     * {@link Ext.grid.Column#renderer renderer} will be needed to show the displayField when the editor is not
     * active.&lt;/p&gt;
     */
<span id='Ext-form-ComboBox-cfg-valueField'>    /**
</span>     * @cfg {String} valueField The underlying {@link Ext.data.Field#name data value name} to bind to this
     * ComboBox (defaults to undefined if &lt;tt&gt;{@link #mode} = 'remote'&lt;/tt&gt; or &lt;tt&gt;'field2'&lt;/tt&gt; if
     * {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on
     * the store configuration}).
     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: use of a &lt;tt&gt;valueField&lt;/tt&gt; requires the user to make a selection in order for a value to be
     * mapped.  See also &lt;tt&gt;{@link #hiddenName}&lt;/tt&gt;, &lt;tt&gt;{@link #hiddenValue}&lt;/tt&gt;, and &lt;tt&gt;{@link #displayField}&lt;/tt&gt;.&lt;/p&gt;
     */
<span id='Ext-form-ComboBox-cfg-hiddenName'>    /**
</span>     * @cfg {String} hiddenName If specified, a hidden form field with this name is dynamically generated to store the
     * field's data value (defaults to the underlying DOM element's name). Required for the combo's value to automatically
     * post during a form submission.  See also {@link #valueField}.
     */
<span id='Ext-form-ComboBox-cfg-hiddenId'>    /**
</span>     * @cfg {String} hiddenId If &lt;tt&gt;{@link #hiddenName}&lt;/tt&gt; is specified, &lt;tt&gt;hiddenId&lt;/tt&gt; can also be provided
     * to give the hidden field a unique id.  The &lt;tt&gt;hiddenId&lt;/tt&gt; and combo {@link Ext.Component#id id} should be
     * different, since no two DOM nodes should share the same id.
     */
<span id='Ext-form-ComboBox-cfg-hiddenValue'>    /**
</span>     * @cfg {String} hiddenValue Sets the initial value of the hidden field if {@link #hiddenName} is
     * specified to contain the selected {@link #valueField}, from the Store. Defaults to the configured
     * &lt;tt&gt;{@link Ext.form.Field#value value}&lt;/tt&gt;.
     */
<span id='Ext-form-ComboBox-cfg-listClass'>    /**
</span>     * @cfg {String} listClass The CSS class to add to the predefined &lt;tt&gt;'x-combo-list'&lt;/tt&gt; class
     * applied the dropdown list element (defaults to '').
     */
    listClass : '',
<span id='Ext-form-ComboBox-cfg-selectedClass'>    /**
</span>     * @cfg {String} selectedClass CSS class to apply to the selected item in the dropdown list
     * (defaults to &lt;tt&gt;'x-combo-selected'&lt;/tt&gt;)
     */
    selectedClass : 'x-combo-selected',
<span id='Ext-form-ComboBox-cfg-listEmptyText'>    /**
</span>     * @cfg {String} listEmptyText The empty text to display in the data view if no items are found.
     * (defaults to '')
     */
    listEmptyText: '',
<span id='Ext-form-ComboBox-cfg-triggerClass'>    /**
</span>     * @cfg {String} triggerClass An additional CSS class used to style the trigger button.  The trigger will always
     * get the class &lt;tt&gt;'x-form-trigger'&lt;/tt&gt; and &lt;tt&gt;triggerClass&lt;/tt&gt; will be &lt;b&gt;appended&lt;/b&gt; if specified
     * (defaults to &lt;tt&gt;'x-form-arrow-trigger'&lt;/tt&gt; which displays a downward arrow icon).
     */
    triggerClass : 'x-form-arrow-trigger',
<span id='Ext-form-ComboBox-cfg-shadow'>    /**
</span>     * @cfg {Boolean/String} shadow &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;&quot;sides&quot;&lt;/tt&gt; for the default effect, &lt;tt&gt;&quot;frame&quot;&lt;/tt&gt; for
     * 4-way shadow, and &lt;tt&gt;&quot;drop&quot;&lt;/tt&gt; for bottom-right
     */
    shadow : 'sides',
<span id='Ext-form-ComboBox-cfg-listAlign'>    /**
</span>     * @cfg {String/Array} listAlign A valid anchor position value. See &lt;tt&gt;{@link Ext.Element#alignTo}&lt;/tt&gt; for details
     * on supported anchor positions and offsets. To specify x/y offsets as well, this value
     * may be specified as an Array of &lt;tt&gt;{@link Ext.Element#alignTo}&lt;/tt&gt; method arguments.&lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;[ 'tl-bl?', [6,0] ]&lt;/code&gt;&lt;/pre&gt;(defaults to &lt;tt&gt;'tl-bl?'&lt;/tt&gt;)
     */
    listAlign : 'tl-bl?',
<span id='Ext-form-ComboBox-cfg-maxHeight'>    /**
</span>     * @cfg {Number} maxHeight The maximum height in pixels of the dropdown list before scrollbars are shown
     * (defaults to &lt;tt&gt;300&lt;/tt&gt;)
     */
    maxHeight : 300,
<span id='Ext-form-ComboBox-cfg-minHeight'>    /**
</span>     * @cfg {Number} minHeight The minimum height in pixels of the dropdown list when the list is constrained by its
     * distance to the viewport edges (defaults to &lt;tt&gt;90&lt;/tt&gt;)
     */
    minHeight : 90,
<span id='Ext-form-ComboBox-cfg-triggerAction'>    /**
</span>     * @cfg {String} triggerAction The action to execute when the trigger is clicked.
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;'query'&lt;/tt&gt;&lt;/b&gt; : &lt;b&gt;Default&lt;/b&gt;
     * &lt;p class=&quot;sub-desc&quot;&gt;{@link #doQuery run the query} using the {@link Ext.form.Field#getRawValue raw value}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;'all'&lt;/tt&gt;&lt;/b&gt; :
     * &lt;p class=&quot;sub-desc&quot;&gt;{@link #doQuery run the query} specified by the &lt;tt&gt;{@link #allQuery}&lt;/tt&gt; config option&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * &lt;p&gt;See also &lt;code&gt;{@link #queryParam}&lt;/code&gt;.&lt;/p&gt;
     */
    triggerAction : 'query',
<span id='Ext-form-ComboBox-cfg-minChars'>    /**
</span>     * @cfg {Number} minChars The minimum number of characters the user must type before autocomplete and
     * {@link #typeAhead} activate (defaults to &lt;tt&gt;4&lt;/tt&gt; if &lt;tt&gt;{@link #mode} = 'remote'&lt;/tt&gt; or &lt;tt&gt;0&lt;/tt&gt; if
     * &lt;tt&gt;{@link #mode} = 'local'&lt;/tt&gt;, does not apply if
     * &lt;tt&gt;{@link Ext.form.TriggerField#editable editable} = false&lt;/tt&gt;).
     */
    minChars : 4,
<span id='Ext-form-ComboBox-cfg-autoSelect'>    /**
</span>     * @cfg {Boolean} autoSelect &lt;tt&gt;true&lt;/tt&gt; to select the first result gathered by the data store (defaults
     * to &lt;tt&gt;true&lt;/tt&gt;).  A false value would require a manual selection from the dropdown list to set the components value
     * unless the value of ({@link #typeAheadDelay}) were true.
     */
    autoSelect : true,
<span id='Ext-form-ComboBox-cfg-typeAhead'>    /**
</span>     * @cfg {Boolean} typeAhead &lt;tt&gt;true&lt;/tt&gt; to populate and autoselect the remainder of the text being
     * typed after a configurable delay ({@link #typeAheadDelay}) if it matches a known value (defaults
     * to &lt;tt&gt;false&lt;/tt&gt;)
     */
    typeAhead : false,
<span id='Ext-form-ComboBox-cfg-queryDelay'>    /**
</span>     * @cfg {Number} queryDelay The length of time in milliseconds to delay between the start of typing and
     * sending the query to filter the dropdown list (defaults to &lt;tt&gt;500&lt;/tt&gt; if &lt;tt&gt;{@link #mode} = 'remote'&lt;/tt&gt;
     * or &lt;tt&gt;10&lt;/tt&gt; if &lt;tt&gt;{@link #mode} = 'local'&lt;/tt&gt;)
     */
    queryDelay : 500,
<span id='Ext-form-ComboBox-cfg-pageSize'>    /**
</span>     * @cfg {Number} pageSize If greater than &lt;tt&gt;0&lt;/tt&gt;, a {@link Ext.PagingToolbar} is displayed in the
     * footer of the dropdown list and the {@link #doQuery filter queries} will execute with page start and
     * {@link Ext.PagingToolbar#pageSize limit} parameters. Only applies when &lt;tt&gt;{@link #mode} = 'remote'&lt;/tt&gt;
     * (defaults to &lt;tt&gt;0&lt;/tt&gt;).
     */
    pageSize : 0,
<span id='Ext-form-ComboBox-cfg-selectOnFocus'>    /**
</span>     * @cfg {Boolean} selectOnFocus &lt;tt&gt;true&lt;/tt&gt; to select any existing text in the field immediately on focus.
     * Only applies when &lt;tt&gt;{@link Ext.form.TriggerField#editable editable} = true&lt;/tt&gt; (defaults to
     * &lt;tt&gt;false&lt;/tt&gt;).
     */
    selectOnFocus : false,
<span id='Ext-form-ComboBox-cfg-queryParam'>    /**
</span>     * @cfg {String} queryParam Name of the query ({@link Ext.data.Store#baseParam baseParam} name for the store)
     * as it will be passed on the querystring (defaults to &lt;tt&gt;'query'&lt;/tt&gt;)
     */
    queryParam : 'query',
<span id='Ext-form-ComboBox-cfg-loadingText'>    /**
</span>     * @cfg {String} loadingText The text to display in the dropdown list while data is loading.  Only applies
     * when &lt;tt&gt;{@link #mode} = 'remote'&lt;/tt&gt; (defaults to &lt;tt&gt;'Loading...'&lt;/tt&gt;)
     */
    loadingText : 'Loading...',
<span id='Ext-form-ComboBox-cfg-resizable'>    /**
</span>     * @cfg {Boolean} resizable &lt;tt&gt;true&lt;/tt&gt; to add a resize handle to the bottom of the dropdown list
     * (creates an {@link Ext.Resizable} with 'se' {@link Ext.Resizable#pinned pinned} handles).
     * Defaults to &lt;tt&gt;false&lt;/tt&gt;.
     */
    resizable : false,
<span id='Ext-form-ComboBox-cfg-handleHeight'>    /**
</span>     * @cfg {Number} handleHeight The height in pixels of the dropdown list resize handle if
     * &lt;tt&gt;{@link #resizable} = true&lt;/tt&gt; (defaults to &lt;tt&gt;8&lt;/tt&gt;)
     */
    handleHeight : 8,
<span id='Ext-form-ComboBox-cfg-allQuery'>    /**
</span>     * @cfg {String} allQuery The text query to send to the server to return all records for the list
     * with no filtering (defaults to '')
     */
    allQuery: '',
<span id='Ext-form-ComboBox-cfg-mode'>    /**
</span>     * @cfg {String} mode Acceptable values are:
     * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;'remote'&lt;/tt&gt;&lt;/b&gt; : &lt;b&gt;Default&lt;/b&gt;
     * &lt;p class=&quot;sub-desc&quot;&gt;Automatically loads the &lt;tt&gt;{@link #store}&lt;/tt&gt; the &lt;b&gt;first&lt;/b&gt; time the trigger
     * is clicked. If you do not want the store to be automatically loaded the first time the trigger is
     * clicked, set to &lt;tt&gt;'local'&lt;/tt&gt; and manually load the store.  To force a requery of the store
     * &lt;b&gt;every&lt;/b&gt; time the trigger is clicked see &lt;tt&gt;{@link #lastQuery}&lt;/tt&gt;.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;&lt;tt&gt;'local'&lt;/tt&gt;&lt;/b&gt; :
     * &lt;p class=&quot;sub-desc&quot;&gt;ComboBox loads local data&lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
var combo = new Ext.form.ComboBox({
    renderTo: document.body,
    mode: 'local',
    store: new Ext.data.ArrayStore({
        id: 0,
        fields: [
            'myId',  // numeric value is the key
            'displayText'
        ],
        data: [[1, 'item1'], [2, 'item2']]  // data is local
    }),
    valueField: 'myId',
    displayField: 'displayText',
    triggerAction: 'all'
});
     * &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     */
    mode: 'remote',
<span id='Ext-form-ComboBox-cfg-minListWidth'>    /**
</span>     * @cfg {Number} minListWidth The minimum width of the dropdown list in pixels (defaults to &lt;tt&gt;70&lt;/tt&gt;, will
     * be ignored if &lt;tt&gt;{@link #listWidth}&lt;/tt&gt; has a higher value)
     */
    minListWidth : 70,
<span id='Ext-form-ComboBox-cfg-forceSelection'>    /**
</span>     * @cfg {Boolean} forceSelection &lt;tt&gt;true&lt;/tt&gt; to restrict the selected value to one of the values in the list,
     * &lt;tt&gt;false&lt;/tt&gt; to allow the user to set arbitrary text into the field (defaults to &lt;tt&gt;false&lt;/tt&gt;)
     */
    forceSelection : false,
<span id='Ext-form-ComboBox-cfg-typeAheadDelay'>    /**
</span>     * @cfg {Number} typeAheadDelay The length of time in milliseconds to wait until the typeahead text is displayed
     * if &lt;tt&gt;{@link #typeAhead} = true&lt;/tt&gt; (defaults to &lt;tt&gt;250&lt;/tt&gt;)
     */
    typeAheadDelay : 250,
<span id='Ext-form-ComboBox-cfg-valueNotFoundText'>    /**
</span>     * @cfg {String} valueNotFoundText When using a name/value combo, if the value passed to setValue is not found in
     * the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined). If this
     * default text is used, it means there is no value set and no validation will occur on this field.
     */

<span id='Ext-form-ComboBox-cfg-lazyInit'>    /**
</span>     * @cfg {Boolean} lazyInit &lt;tt&gt;true&lt;/tt&gt; to not initialize the list for this combo until the field is focused
     * (defaults to &lt;tt&gt;true&lt;/tt&gt;)
     */
    lazyInit : true,

<span id='Ext-form-ComboBox-cfg-clearFilterOnReset'>    /**
</span>     * @cfg {Boolean} clearFilterOnReset &lt;tt&gt;true&lt;/tt&gt; to clear any filters on the store (when in local mode) when reset is called
     * (defaults to &lt;tt&gt;true&lt;/tt&gt;)
     */
    clearFilterOnReset : true,

<span id='Ext-form-ComboBox-cfg-submitValue'>    /**
</span>     * @cfg {Boolean} submitValue False to clear the name attribute on the field so that it is not submitted during a form post.
     * If a hiddenName is specified, setting this to true will cause both the hidden field and the element to be submitted.
     * Defaults to &lt;tt&gt;undefined&lt;/tt&gt;.
     */
    submitValue: undefined,

<span id='Ext-form-ComboBox-property-lastQuery'>    /**
</span>     * The value of the match string used to filter the store. Delete this property to force a requery.
     * Example use:
     * &lt;pre&gt;&lt;code&gt;
var combo = new Ext.form.ComboBox({
    ...
    mode: 'remote',
    ...
    listeners: {
        // delete the previous query in the beforequery event or set
        // combo.lastQuery = null (this will reload the store the next time it expands)
        beforequery: function(qe){
            delete qe.combo.lastQuery;
        }
    }
});
     * &lt;/code&gt;&lt;/pre&gt;
     * To make sure the filter in the store is not cleared the first time the ComboBox trigger is used
     * configure the combo with &lt;tt&gt;lastQuery=''&lt;/tt&gt;. Example use:
     * &lt;pre&gt;&lt;code&gt;
var combo = new Ext.form.ComboBox({
    ...
    mode: 'local',
    triggerAction: 'all',
    lastQuery: ''
});
     * &lt;/code&gt;&lt;/pre&gt;
     * @property lastQuery
     * @type String
     */

<span id='Ext-form-ComboBox-method-initComponent'>    // private
</span>    initComponent : function(){
        Ext.form.ComboBox.superclass.initComponent.call(this);
        this.addEvents(
<span id='Ext-form-ComboBox-event-expand'>            /**
</span>             * @event expand
             * Fires when the dropdown list is expanded
             * @param {Ext.form.ComboBox} combo This combo box
             */
            'expand',
<span id='Ext-form-ComboBox-event-collapse'>            /**
</span>             * @event collapse
             * Fires when the dropdown list is collapsed
             * @param {Ext.form.ComboBox} combo This combo box
             */
            'collapse',

<span id='Ext-form-ComboBox-event-beforeselect'>            /**
</span>             * @event beforeselect
             * Fires before a list item is selected. Return false to cancel the selection.
             * @param {Ext.form.ComboBox} combo This combo box
             * @param {Ext.data.Record} record The data record returned from the underlying store
             * @param {Number} index The index of the selected item in the dropdown list
             */
            'beforeselect',
<span id='Ext-form-ComboBox-event-select'>            /**
</span>             * @event select
             * Fires when a list item is selected
             * @param {Ext.form.ComboBox} combo This combo box
             * @param {Ext.data.Record} record The data record returned from the underlying store
             * @param {Number} index The index of the selected item in the dropdown list
             */
            'select',
<span id='Ext-form-ComboBox-event-beforequery'>            /**
</span>             * @event beforequery
             * Fires before all queries are processed. Return false to cancel the query or set the queryEvent's
             * cancel property to true.
             * @param {Object} queryEvent An object that has these properties:&lt;ul&gt;
             * &lt;li&gt;&lt;code&gt;combo&lt;/code&gt; : Ext.form.ComboBox &lt;div class=&quot;sub-desc&quot;&gt;This combo box&lt;/div&gt;&lt;/li&gt;
             * &lt;li&gt;&lt;code&gt;query&lt;/code&gt; : String &lt;div class=&quot;sub-desc&quot;&gt;The query&lt;/div&gt;&lt;/li&gt;
             * &lt;li&gt;&lt;code&gt;forceAll&lt;/code&gt; : Boolean &lt;div class=&quot;sub-desc&quot;&gt;True to force &quot;all&quot; query&lt;/div&gt;&lt;/li&gt;
             * &lt;li&gt;&lt;code&gt;cancel&lt;/code&gt; : Boolean &lt;div class=&quot;sub-desc&quot;&gt;Set to true to cancel the query&lt;/div&gt;&lt;/li&gt;
             * &lt;/ul&gt;
             */
            'beforequery'
        );
        if(this.transform){
            var s = Ext.getDom(this.transform);
            if(!this.hiddenName){
                this.hiddenName = s.name;
            }
            if(!this.store){
                this.mode = 'local';
                var d = [], opts = s.options;
                for(var i = 0, len = opts.length;i &lt; len; i++){
                    var o = opts[i],
                        value = (o.hasAttribute ? o.hasAttribute('value') : o.getAttributeNode('value').specified) ? o.value : o.text;
                    if(o.selected &amp;&amp; Ext.isEmpty(this.value, true)) {
                        this.value = value;
                    }
                    d.push([value, o.text]);
                }
                this.store = new Ext.data.ArrayStore({
                    idIndex: 0,
                    fields: ['value', 'text'],
                    data : d,
                    autoDestroy: true
                });
                this.valueField = 'value';
                this.displayField = 'text';
            }
            s.name = Ext.id(); // wipe out the name in case somewhere else they have a reference
            if(!this.lazyRender){
                this.target = true;
                this.el = Ext.DomHelper.insertBefore(s, this.autoCreate || this.defaultAutoCreate);
                this.render(this.el.parentNode, s);
            }
            Ext.removeNode(s);
        }
        //auto-configure store from local array data
        else if(this.store){
            this.store = Ext.StoreMgr.lookup(this.store);
            if(this.store.autoCreated){
                this.displayField = this.valueField = 'field1';
                if(!this.store.expandData){
                    this.displayField = 'field2';
                }
                this.mode = 'local';
            }
        }

        this.selectedIndex = -1;
        if(this.mode == 'local'){
            if(!Ext.isDefined(this.initialConfig.queryDelay)){
                this.queryDelay = 10;
            }
            if(!Ext.isDefined(this.initialConfig.minChars)){
                this.minChars = 0;
            }
        }
    },

<span id='Ext-form-ComboBox-method-onRender'>    // private
</span>    onRender : function(ct, position){
        if(this.hiddenName &amp;&amp; !Ext.isDefined(this.submitValue)){
            this.submitValue = false;
        }
        Ext.form.ComboBox.superclass.onRender.call(this, ct, position);
        if(this.hiddenName){
            this.hiddenField = this.el.insertSibling({tag:'input', type:'hidden', name: this.hiddenName,
                    id: (this.hiddenId || Ext.id())}, 'before', true);

        }
        if(Ext.isGecko){
            this.el.dom.setAttribute('autocomplete', 'off');
        }

        if(!this.lazyInit){
            this.initList();
        }else{
            this.on('focus', this.initList, this, {single: true});
        }
    },

<span id='Ext-form-ComboBox-method-initValue'>    // private
</span>    initValue : function(){
        Ext.form.ComboBox.superclass.initValue.call(this);
        if(this.hiddenField){
            this.hiddenField.value =
                Ext.value(Ext.isDefined(this.hiddenValue) ? this.hiddenValue : this.value, '');
        }
    },

<span id='Ext-form-ComboBox-method-getParentZIndex'>    getParentZIndex : function(){
</span>        var zindex;
        if (this.ownerCt){
            this.findParentBy(function(ct){
                zindex = parseInt(ct.getPositionEl().getStyle('z-index'), 10);
                return !!zindex;
            });
        }
        return zindex;
    },

<span id='Ext-form-ComboBox-method-getZIndex'>    getZIndex : function(listParent){
</span>        listParent = listParent || Ext.getDom(this.getListParent() || Ext.getBody());
        var zindex = parseInt(Ext.fly(listParent).getStyle('z-index'), 10);
        if(!zindex){
            zindex = this.getParentZIndex();
        }
        return (zindex || 12000) + 5;
    },

<span id='Ext-form-ComboBox-method-initList'>    // private
</span>    initList : function(){
        if(!this.list){
            var cls = 'x-combo-list',
                listParent = Ext.getDom(this.getListParent() || Ext.getBody());

            this.list = new Ext.Layer({
                parentEl: listParent,
                shadow: this.shadow,
                cls: [cls, this.listClass].join(' '),
                constrain:false,
                zindex: this.getZIndex(listParent)
            });

            var lw = this.listWidth || Math.max(this.wrap.getWidth(), this.minListWidth);
            this.list.setSize(lw, 0);
            this.list.swallowEvent('mousewheel');
            this.assetHeight = 0;
            if(this.syncFont !== false){
                this.list.setStyle('font-size', this.el.getStyle('font-size'));
            }
            if(this.title){
                this.header = this.list.createChild({cls:cls+'-hd', html: this.title});
                this.assetHeight += this.header.getHeight();
            }

            this.innerList = this.list.createChild({cls:cls+'-inner'});
            this.mon(this.innerList, 'mouseover', this.onViewOver, this);
            this.mon(this.innerList, 'mousemove', this.onViewMove, this);
            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));

            if(this.pageSize){
                this.footer = this.list.createChild({cls:cls+'-ft'});
                this.pageTb = new Ext.PagingToolbar({
                    store: this.store,
                    pageSize: this.pageSize,
                    renderTo:this.footer
                });
                this.assetHeight += this.footer.getHeight();
            }

            if(!this.tpl){
<span id='Ext-form-ComboBox-cfg-tpl'>                /**
</span>                * @cfg {String/Ext.XTemplate} tpl &lt;p&gt;The template string, or {@link Ext.XTemplate} instance to
                * use to display each item in the dropdown list. The dropdown list is displayed in a
                * DataView. See {@link #view}.&lt;/p&gt;
                * &lt;p&gt;The default template string is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
                  '&amp;lt;tpl for=&quot;.&quot;&gt;&amp;lt;div class=&quot;x-combo-list-item&quot;&gt;{' + this.displayField + '}&amp;lt;/div&gt;&amp;lt;/tpl&gt;'
                * &lt;/code&gt;&lt;/pre&gt;
                * &lt;p&gt;Override the default value to create custom UI layouts for items in the list.
                * For example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
                  '&amp;lt;tpl for=&quot;.&quot;&gt;&amp;lt;div ext:qtip=&quot;{state}. {nick}&quot; class=&quot;x-combo-list-item&quot;&gt;{state}&amp;lt;/div&gt;&amp;lt;/tpl&gt;'
                * &lt;/code&gt;&lt;/pre&gt;
                * &lt;p&gt;The template &lt;b&gt;must&lt;/b&gt; contain one or more substitution parameters using field
                * names from the Combo's&lt;/b&gt; {@link #store Store}. In the example above an
                * &lt;pre&gt;ext:qtip&lt;/pre&gt; attribute is added to display other fields from the Store.&lt;/p&gt;
                * &lt;p&gt;To preserve the default visual look of list items, add the CSS class name
                * &lt;pre&gt;x-combo-list-item&lt;/pre&gt; to the template's container element.&lt;/p&gt;
                * &lt;p&gt;Also see {@link #itemSelector} for additional details.&lt;/p&gt;
                */
                this.tpl = '&lt;tpl for=&quot;.&quot;&gt;&lt;div class=&quot;'+cls+'-item&quot;&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;';
<span id='Ext-form-ComboBox-cfg-itemSelector'>                /**
</span>                 * @cfg {String} itemSelector
                 * &lt;p&gt;A simple CSS selector (e.g. div.some-class or span:first-child) that will be
                 * used to determine what nodes the {@link #view Ext.DataView} which handles the dropdown
                 * display will be working with.&lt;/p&gt;
                 * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: this setting is &lt;b&gt;required&lt;/b&gt; if a custom XTemplate has been
                 * specified in {@link #tpl} which assigns a class other than &lt;pre&gt;'x-combo-list-item'&lt;/pre&gt;
                 * to dropdown list items&lt;/b&gt;
                 */
            }

<span id='Ext-form-ComboBox-property-view'>            /**
</span>            * The {@link Ext.DataView DataView} used to display the ComboBox's options.
            * @type Ext.DataView
            */
            this.view = new Ext.DataView({
                applyTo: this.innerList,
                tpl: this.tpl,
                singleSelect: true,
                selectedClass: this.selectedClass,
                itemSelector: this.itemSelector || '.' + cls + '-item',
                emptyText: this.listEmptyText,
                deferEmptyText: false
            });

            this.mon(this.view, {
                containerclick : this.onViewClick,
                click : this.onViewClick,
                scope :this
            });

            this.bindStore(this.store, true);

            if(this.resizable){
                this.resizer = new Ext.Resizable(this.list,  {
                   pinned:true, handles:'se'
                });
                this.mon(this.resizer, 'resize', function(r, w, h){
                    this.maxHeight = h-this.handleHeight-this.list.getFrameWidth('tb')-this.assetHeight;
                    this.listWidth = w;
                    this.innerList.setWidth(w - this.list.getFrameWidth('lr'));
                    this.restrictHeight();
                }, this);

                this[this.pageSize?'footer':'innerList'].setStyle('margin-bottom', this.handleHeight+'px');
            }
        }
    },

<span id='Ext-form-ComboBox-method-getListParent'>    /**
</span>     * &lt;p&gt;Returns the element used to house this ComboBox's pop-up list. Defaults to the document body.&lt;/p&gt;
     * A custom implementation may be provided as a configuration option if the floating list needs to be rendered
     * to a different Element. An example might be rendering the list inside a Menu so that clicking
     * the list does not hide the Menu:&lt;pre&gt;&lt;code&gt;
var store = new Ext.data.ArrayStore({
    autoDestroy: true,
    fields: ['initials', 'fullname'],
    data : [
        ['FF', 'Fred Flintstone'],
        ['BR', 'Barney Rubble']
    ]
});

var combo = new Ext.form.ComboBox({
    store: store,
    displayField: 'fullname',
    emptyText: 'Select a name...',
    forceSelection: true,
    getListParent: function() {
        return this.el.up('.x-menu');
    },
    iconCls: 'no-icon', //use iconCls if placing within menu to shift to right side of menu
    mode: 'local',
    selectOnFocus: true,
    triggerAction: 'all',
    typeAhead: true,
    width: 135
});

var menu = new Ext.menu.Menu({
    id: 'mainMenu',
    items: [
        combo // A Field in a Menu
    ]
});
&lt;/code&gt;&lt;/pre&gt;
     */
    getListParent : function() {
        return document.body;
    },

<span id='Ext-form-ComboBox-method-getStore'>    /**
</span>     * Returns the store associated with this combo.
     * @return {Ext.data.Store} The store
     */
    getStore : function(){
        return this.store;
    },

<span id='Ext-form-ComboBox-method-bindStore'>    // private
</span>    bindStore : function(store, initial){
        if(this.store &amp;&amp; !initial){
            if(this.store !== store &amp;&amp; this.store.autoDestroy){
                this.store.destroy();
            }else{
                this.store.un('beforeload', this.onBeforeLoad, this);
                this.store.un('load', this.onLoad, this);
                this.store.un('exception', this.collapse, this);
            }
            if(!store){
                this.store = null;
                if(this.view){
                    this.view.bindStore(null);
                }
                if(this.pageTb){
                    this.pageTb.bindStore(null);
                }
            }
        }
        if(store){
            if(!initial) {
                this.lastQuery = null;
                if(this.pageTb) {
                    this.pageTb.bindStore(store);
                }
            }

            this.store = Ext.StoreMgr.lookup(store);
            this.store.on({
                scope: this,
                beforeload: this.onBeforeLoad,
                load: this.onLoad,
                exception: this.collapse
            });

            if(this.view){
                this.view.bindStore(store);
            }
        }
    },

<span id='Ext-form-ComboBox-method-reset'>    reset : function(){
</span>        if(this.clearFilterOnReset &amp;&amp; this.mode == 'local'){
            this.store.clearFilter();
        }
        Ext.form.ComboBox.superclass.reset.call(this);
    },

<span id='Ext-form-ComboBox-method-initEvents'>    // private
</span>    initEvents : function(){
        Ext.form.ComboBox.superclass.initEvents.call(this);

<span id='Ext-form-ComboBox-property-keyNav'>        /**
</span>         * @property keyNav
         * @type Ext.KeyNav
         * &lt;p&gt;A {@link Ext.KeyNav KeyNav} object which handles navigation keys for this ComboBox. This performs actions
         * based on keystrokes typed when the input field is focused.&lt;/p&gt;
         * &lt;p&gt;&lt;b&gt;After the ComboBox has been rendered&lt;/b&gt;, you may override existing navigation key functionality,
         * or add your own based upon key names as specified in the {@link Ext.KeyNav KeyNav} class.&lt;/p&gt;
         * &lt;p&gt;The function is executed in the scope (&lt;code&gt;this&lt;/code&gt; reference of the ComboBox. Example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;
myCombo.keyNav.esc = function(e) {  // Override ESC handling function
    this.collapse();                // Standard behaviour of Ext's ComboBox.
    this.setValue(this.startValue); // We reset to starting value on ESC
};
myCombo.keyNav.tab = function() {   // Override TAB handling function
    this.onViewClick(false);        // Select the currently highlighted row
};
&lt;/code&gt;&lt;/pre&gt;
         */
        this.keyNav = new Ext.KeyNav(this.el, {
            &quot;up&quot; : function(e){
                this.inKeyMode = true;
                this.selectPrev();
            },

            &quot;down&quot; : function(e){
                if(!this.isExpanded()){
                    this.onTriggerClick();
                }else{
                    this.inKeyMode = true;
                    this.selectNext();
                }
            },

            &quot;enter&quot; : function(e){
                this.onViewClick();
            },

            &quot;esc&quot; : function(e){
                this.collapse();
            },

            &quot;tab&quot; : function(e){
                if (this.forceSelection === true) {
                    this.collapse();
                } else {
                    this.onViewClick(false);
                }
                return true;
            },

            scope : this,

            doRelay : function(e, h, hname){
                if(hname == 'down' || this.scope.isExpanded()){
                    // this MUST be called before ComboBox#fireKey()
                    var relay = Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    if((((Ext.isIE9 &amp;&amp; Ext.isStrict) || Ext.isIE10p) || !Ext.isIE) &amp;&amp; Ext.EventManager.useKeydown){
                        // call Combo#fireKey() for browsers which use keydown event (except IE)
                        this.scope.fireKey(e);
                    }
                    return relay;
                }
                return true;
            },

            forceKeyDown : true,
            defaultEventAction: 'stopEvent'
        });
        this.queryDelay = Math.max(this.queryDelay || 10,
                this.mode == 'local' ? 10 : 250);
        this.dqTask = new Ext.util.DelayedTask(this.initQuery, this);
        if(this.typeAhead){
            this.taTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
        }
        if(!this.enableKeyEvents){
            this.mon(this.el, 'keyup', this.onKeyUp, this);
        }
    },


<span id='Ext-form-ComboBox-method-onDestroy'>    // private
</span>    onDestroy : function(){
        if (this.dqTask){
            this.dqTask.cancel();
            this.dqTask = null;
        }
        this.bindStore(null);
        Ext.destroy(
            this.resizer,
            this.view,
            this.pageTb,
            this.list
        );
        Ext.destroyMembers(this, 'hiddenField');
        Ext.form.ComboBox.superclass.onDestroy.call(this);
    },

<span id='Ext-form-ComboBox-method-fireKey'>    // private
</span>    fireKey : function(e){
        if (!this.isExpanded()) {
            Ext.form.ComboBox.superclass.fireKey.call(this, e);
        }
    },

<span id='Ext-form-ComboBox-method-onResize'>    // private
</span>    onResize : function(w, h){
        Ext.form.ComboBox.superclass.onResize.apply(this, arguments);
        if(!isNaN(w) &amp;&amp; this.isVisible() &amp;&amp; this.list){
            this.doResize(w);
        }else{
            this.bufferSize = w;
        }
    },

<span id='Ext-form-ComboBox-method-doResize'>    doResize: function(w){
</span>        if(!Ext.isDefined(this.listWidth)){
            var lw = Math.max(w, this.minListWidth);
            this.list.setWidth(lw);
            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));
        }
    },

<span id='Ext-form-ComboBox-method-onEnable'>    // private
</span>    onEnable : function(){
        Ext.form.ComboBox.superclass.onEnable.apply(this, arguments);
        if(this.hiddenField){
            this.hiddenField.disabled = false;
        }
    },

<span id='Ext-form-ComboBox-method-onDisable'>    // private
</span>    onDisable : function(){
        Ext.form.ComboBox.superclass.onDisable.apply(this, arguments);
        if(this.hiddenField){
            this.hiddenField.disabled = true;
        }
    },

<span id='Ext-form-ComboBox-method-onBeforeLoad'>    // private
</span>    onBeforeLoad : function(){
        if(!this.hasFocus){
            return;
        }
        this.innerList.update(this.loadingText ?
               '&lt;div class=&quot;loading-indicator&quot;&gt;'+this.loadingText+'&lt;/div&gt;' : '');
        this.restrictHeight();
        this.selectedIndex = -1;
    },

<span id='Ext-form-ComboBox-method-onLoad'>    // private
</span>    onLoad : function(){
        if(!this.hasFocus){
            return;
        }
        if(this.store.getCount() &gt; 0 || this.listEmptyText){
            this.expand();
            this.restrictHeight();
            if(this.lastQuery == this.allQuery){
                if(this.editable){
                    this.el.dom.select();
                }

                if(this.autoSelect !== false &amp;&amp; !this.selectByValue(this.value, true)){
                    this.select(0, true);
                }
            }else{
                if(this.autoSelect !== false){
                    this.selectNext();
                }
                if(this.typeAhead &amp;&amp; this.lastKey != Ext.EventObject.BACKSPACE &amp;&amp; this.lastKey != Ext.EventObject.DELETE){
                    this.taTask.delay(this.typeAheadDelay);
                }
            }
        }else{
            this.collapse();
        }

    },

<span id='Ext-form-ComboBox-method-onTypeAhead'>    // private
</span>    onTypeAhead : function(){
        if(this.store.getCount() &gt; 0){
            var r = this.store.getAt(0);
            var newValue = r.data[this.displayField];
            var len = newValue.length;
            var selStart = this.getRawValue().length;
            if(selStart != len){
                this.setRawValue(newValue);
                this.selectText(selStart, newValue.length);
            }
        }
    },

<span id='Ext-form-ComboBox-method-assertValue'>    // private
</span>    assertValue : function(){
        var val = this.getRawValue(),
            rec;

        if(this.valueField &amp;&amp; Ext.isDefined(this.value)){
            rec = this.findRecord(this.valueField, this.value);
        }
        if(!rec || rec.get(this.displayField) != val){
            rec = this.findRecord(this.displayField, val);
        }
        if(!rec &amp;&amp; this.forceSelection){
            if(val.length &gt; 0 &amp;&amp; val != this.emptyText){
                this.el.dom.value = Ext.value(this.lastSelectionText, '');
                this.applyEmptyText();
            }else{
                this.clearValue();
            }
        }else{
            if(rec &amp;&amp; this.valueField){
                // onSelect may have already set the value and by doing so
                // set the display field properly.  Let's not wipe out the
                // valueField here by just sending the displayField.
                if (this.value == val){
                    return;
                }
                val = rec.get(this.valueField || this.displayField);
            }
            this.setValue(val);
        }
    },

<span id='Ext-form-ComboBox-method-onSelect'>    // private
</span>    onSelect : function(record, index){
        if(this.fireEvent('beforeselect', this, record, index) !== false){
            this.setValue(record.data[this.valueField || this.displayField]);
            this.collapse();
            this.fireEvent('select', this, record, index);
        }
    },

<span id='Ext-form-ComboBox-method-getName'>    // inherit docs
</span>    getName: function(){
        var hf = this.hiddenField;
        return hf &amp;&amp; hf.name ? hf.name : this.hiddenName || Ext.form.ComboBox.superclass.getName.call(this);
    },

<span id='Ext-form-ComboBox-method-getValue'>    /**
</span>     * Returns the currently selected field value or empty string if no value is set.
     * @return {String} value The selected value
     */
    getValue : function(){
        if(this.valueField){
            return Ext.isDefined(this.value) ? this.value : '';
        }else{
            return Ext.form.ComboBox.superclass.getValue.call(this);
        }
    },

<span id='Ext-form-ComboBox-method-clearValue'>    /**
</span>     * Clears any text/value currently set in the field
     */
    clearValue : function(){
        if(this.hiddenField){
            this.hiddenField.value = '';
        }
        this.setRawValue('');
        this.lastSelectionText = '';
        this.applyEmptyText();
        this.value = '';
    },

<span id='Ext-form-ComboBox-method-setValue'>    /**
</span>     * Sets the specified value into the field.  If the value finds a match, the corresponding record text
     * will be displayed in the field.  If the value does not match the data value of an existing item,
     * and the valueNotFoundText config option is defined, it will be displayed as the default field text.
     * Otherwise the field will be blank (although the value will still be set).
     * @param {String} value The value to match
     * @return {Ext.form.Field} this
     */
    setValue : function(v){
        var text = v;
        if(this.valueField){
            var r = this.findRecord(this.valueField, v);
            if(r){
                text = r.data[this.displayField];
            }else if(Ext.isDefined(this.valueNotFoundText)){
                text = this.valueNotFoundText;
            }
        }
        this.lastSelectionText = text;
        if(this.hiddenField){
            this.hiddenField.value = Ext.value(v, '');
        }
        Ext.form.ComboBox.superclass.setValue.call(this, text);
        this.value = v;
        return this;
    },

<span id='Ext-form-ComboBox-method-findRecord'>    // private
</span>    findRecord : function(prop, value){
        var record;
        if(this.store.getCount() &gt; 0){
            this.store.each(function(r){
                if(r.data[prop] == value){
                    record = r;
                    return false;
                }
            });
        }
        return record;
    },

<span id='Ext-form-ComboBox-method-onViewMove'>    // private
</span>    onViewMove : function(e, t){
        this.inKeyMode = false;
    },

<span id='Ext-form-ComboBox-method-onViewOver'>    // private
</span>    onViewOver : function(e, t){
        if(this.inKeyMode){ // prevent key nav and mouse over conflicts
            return;
        }
        var item = this.view.findItemFromChild(t);
        if(item){
            var index = this.view.indexOf(item);
            this.select(index, false);
        }
    },

<span id='Ext-form-ComboBox-method-onViewClick'>    // private
</span>    onViewClick : function(doFocus){
        var index = this.view.getSelectedIndexes()[0],
            s = this.store,
            r = s.getAt(index);
        if(r){
            this.onSelect(r, index);
        }else {
            this.collapse();
        }
        if(doFocus !== false){
            this.el.focus();
        }
    },


<span id='Ext-form-ComboBox-method-restrictHeight'>    // private
</span>    restrictHeight : function(){
        this.innerList.dom.style.height = '';
        var inner = this.innerList.dom,
            pad = this.list.getFrameWidth('tb') + (this.resizable ? this.handleHeight : 0) + this.assetHeight,
            h = Math.max(inner.clientHeight, inner.offsetHeight, inner.scrollHeight),
            ha = this.getPosition()[1]-Ext.getBody().getScroll().top,
            hb = Ext.lib.Dom.getViewHeight()-ha-this.getSize().height,
            space = Math.max(ha, hb, this.minHeight || 0)-this.list.shadowOffset-pad-5;

        h = Math.min(h, space, this.maxHeight);

        this.innerList.setHeight(h);
        this.list.beginUpdate();
        this.list.setHeight(h+pad);
        this.list.alignTo.apply(this.list, [this.el].concat(this.listAlign));
        this.list.endUpdate();
    },

<span id='Ext-form-ComboBox-method-isExpanded'>    /**
</span>     * Returns true if the dropdown list is expanded, else false.
     */
    isExpanded : function(){
        return this.list &amp;&amp; this.list.isVisible();
    },

<span id='Ext-form-ComboBox-method-selectByValue'>    /**
</span>     * Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
     * @param {String} value The data value of the item to select
     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
     * selected item if it is not currently in view (defaults to true)
     * @return {Boolean} True if the value matched an item in the list, else false
     */
    selectByValue : function(v, scrollIntoView){
        if(!Ext.isEmpty(v, true)){
            var r = this.findRecord(this.valueField || this.displayField, v);
            if(r){
                this.select(this.store.indexOf(r), scrollIntoView);
                return true;
            }
        }
        return false;
    },

<span id='Ext-form-ComboBox-method-select'>    /**
</span>     * Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
     * @param {Number} index The zero-based index of the list item to select
     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
     * selected item if it is not currently in view (defaults to true)
     */
    select : function(index, scrollIntoView){
        this.selectedIndex = index;
        this.view.select(index);
        if(scrollIntoView !== false){
            var el = this.view.getNode(index);
            if(el){
                this.innerList.scrollChildIntoView(el, false);
            }
        }

    },

<span id='Ext-form-ComboBox-method-selectNext'>    // private
</span>    selectNext : function(){
        var ct = this.store.getCount();
        if(ct &gt; 0){
            if(this.selectedIndex == -1){
                this.select(0);
            }else if(this.selectedIndex &lt; ct-1){
                this.select(this.selectedIndex+1);
            }
        }
    },

<span id='Ext-form-ComboBox-method-selectPrev'>    // private
</span>    selectPrev : function(){
        var ct = this.store.getCount();
        if(ct &gt; 0){
            if(this.selectedIndex == -1){
                this.select(0);
            }else if(this.selectedIndex !== 0){
                this.select(this.selectedIndex-1);
            }
        }
    },

<span id='Ext-form-ComboBox-method-onKeyUp'>    // private
</span>    onKeyUp : function(e){
        var k = e.getKey();
        if(this.editable !== false &amp;&amp; this.readOnly !== true &amp;&amp; (k == e.BACKSPACE || !e.isSpecialKey())){

            this.lastKey = k;
            this.dqTask.delay(this.queryDelay);
        }
        Ext.form.ComboBox.superclass.onKeyUp.call(this, e);
    },

<span id='Ext-form-ComboBox-method-validateBlur'>    // private
</span>    validateBlur : function(){
        return !this.list || !this.list.isVisible();
    },

<span id='Ext-form-ComboBox-method-initQuery'>    // private
</span>    initQuery : function(){
        this.doQuery(this.getRawValue());
    },

<span id='Ext-form-ComboBox-method-beforeBlur'>    // private
</span>    beforeBlur : function(){
        this.assertValue();
    },

<span id='Ext-form-ComboBox-method-postBlur'>    // private
</span>    postBlur  : function(){
        Ext.form.ComboBox.superclass.postBlur.call(this);
        this.collapse();
        this.inKeyMode = false;
    },

<span id='Ext-form-ComboBox-method-doQuery'>    /**
</span>     * Execute a query to filter the dropdown list.  Fires the {@link #beforequery} event prior to performing the
     * query allowing the query action to be canceled if needed.
     * @param {String} query The SQL query to execute
     * @param {Boolean} forceAll &lt;tt&gt;true&lt;/tt&gt; to force the query to execute even if there are currently fewer
     * characters in the field than the minimum specified by the &lt;tt&gt;{@link #minChars}&lt;/tt&gt; config option.  It
     * also clears any filter previously saved in the current store (defaults to &lt;tt&gt;false&lt;/tt&gt;)
     */
    doQuery : function(q, forceAll){
        q = Ext.isEmpty(q) ? '' : q;
        var qe = {
            query: q,
            forceAll: forceAll,
            combo: this,
            cancel:false
        };
        if(this.fireEvent('beforequery', qe)===false || qe.cancel){
            return false;
        }
        q = qe.query;
        forceAll = qe.forceAll;
        if(forceAll === true || (q.length &gt;= this.minChars)){
            if(this.lastQuery !== q){
                this.lastQuery = q;
                if(this.mode == 'local'){
                    this.selectedIndex = -1;
                    if(forceAll){
                        this.store.clearFilter();
                    }else{
                        this.store.filter(this.displayField, q);
                    }
                    this.onLoad();
                }else{
                    this.store.baseParams[this.queryParam] = q;
                    this.store.load({
                        params: this.getParams(q)
                    });
                    this.expand();
                }
            }else{
                this.selectedIndex = -1;
                this.onLoad();
            }
        }
    },

<span id='Ext-form-ComboBox-method-getParams'>    // private
</span>    getParams : function(q){
        var params = {},
            paramNames = this.store.paramNames;
        if(this.pageSize){
            params[paramNames.start] = 0;
            params[paramNames.limit] = this.pageSize;
        }
        return params;
    },

<span id='Ext-form-ComboBox-method-collapse'>    /**
</span>     * Hides the dropdown list if it is currently expanded. Fires the {@link #collapse} event on completion.
     */
    collapse : function(){
        if(!this.isExpanded()){
            return;
        }
        this.list.hide();
        Ext.getDoc().un('mousewheel', this.collapseIf, this);
        Ext.getDoc().un('mousedown', this.collapseIf, this);
        this.fireEvent('collapse', this);
    },

<span id='Ext-form-ComboBox-method-collapseIf'>    // private
</span>    collapseIf : function(e){
        if(!this.isDestroyed &amp;&amp; !e.within(this.wrap) &amp;&amp; !e.within(this.list)){
            this.collapse();
        }
    },

<span id='Ext-form-ComboBox-method-expand'>    /**
</span>     * Expands the dropdown list if it is currently hidden. Fires the {@link #expand} event on completion.
     */
    expand : function(){
        if(this.isExpanded() || !this.hasFocus){
            return;
        }

        if(this.title || this.pageSize){
            this.assetHeight = 0;
            if(this.title){
                this.assetHeight += this.header.getHeight();
            }
            if(this.pageSize){
                this.assetHeight += this.footer.getHeight();
            }
        }

        if(this.bufferSize){
            this.doResize(this.bufferSize);
            delete this.bufferSize;
        }
        this.list.alignTo.apply(this.list, [this.el].concat(this.listAlign));

        // zindex can change, re-check it and set it if necessary
        this.list.setZIndex(this.getZIndex());
        this.list.show();
        if(Ext.isGecko2){
            this.innerList.setOverflow('auto'); // necessary for FF 2.0/Mac
        }
        this.mon(Ext.getDoc(), {
            scope: this,
            mousewheel: this.collapseIf,
            mousedown: this.collapseIf
        });
        this.fireEvent('expand', this);
    },

<span id='Ext-form-ComboBox-method-onTriggerClick'>    /**
</span>     * @method onTriggerClick
     * @hide
     */
<span id='Ext-form-ComboBox-method-onTriggerClick'>    // private
</span>    // Implements the default empty TriggerField.onTriggerClick function
    onTriggerClick : function(){
        if(this.readOnly || this.disabled){
            return;
        }
        if(this.isExpanded()){
            this.collapse();
            this.el.focus();
        }else {
            this.onFocus({});
            if(this.triggerAction == 'all') {
                this.doQuery(this.allQuery, true);
            } else {
                this.doQuery(this.getRawValue());
            }
            this.el.focus();
        }
    }

<span id='Ext-form-ComboBox-method-autoSize'>    /**
</span>     * @hide
     * @method autoSize
     */
<span id='Ext-form-ComboBox-cfg-grow'>    /**
</span>     * @cfg {Boolean} grow @hide
     */
<span id='Ext-form-ComboBox-cfg-growMin'>    /**
</span>     * @cfg {Number} growMin @hide
     */
<span id='Ext-form-ComboBox-cfg-growMax'>    /**
</span>     * @cfg {Number} growMax @hide
     */

});
Ext.reg('combo', Ext.form.ComboBox);
</pre>
</body>
</html>
