<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-Record-method-constructor'><span id='Ext-data-Record'>/**
</span></span> * @class Ext.data.Record
 * &lt;p&gt;Instances of this class encapsulate both Record &lt;em&gt;definition&lt;/em&gt; information, and Record
 * &lt;em&gt;value&lt;/em&gt; information for use in {@link Ext.data.Store} objects, or any code which needs
 * to access Records cached in an {@link Ext.data.Store} object.&lt;/p&gt;
 * &lt;p&gt;Constructors for this class are generated by passing an Array of field definition objects to {@link #create}.
 * Instances are usually only created by {@link Ext.data.Reader} implementations when processing unformatted data
 * objects.&lt;/p&gt;
 * &lt;p&gt;Note that an instance of a Record class may only belong to one {@link Ext.data.Store Store} at a time.
 * In order to copy data from one Store to another, use the {@link #copy} method to create an exact
 * copy of the Record, and insert the new instance into the other Store.&lt;/p&gt;
 * &lt;p&gt;When serializing a Record for submission to the server, be aware that it contains many private
 * properties, and also a reference to its owning Store which in turn holds references to its Records.
 * This means that a whole Record may not be encoded using {@link Ext.util.JSON.encode}. Instead, use the
 * &lt;code&gt;{@link #data}&lt;/code&gt; and &lt;code&gt;{@link #id}&lt;/code&gt; properties.&lt;/p&gt;
 * &lt;p&gt;Record objects generated by this constructor inherit all the methods of Ext.data.Record listed below.&lt;/p&gt;
 * @constructor
 * &lt;p&gt;This constructor should not be used to create Record objects. Instead, use {@link #create} to
 * generate a subclass of Ext.data.Record configured with information about its constituent fields.&lt;p&gt;
 * &lt;p&gt;&lt;b&gt;The generated constructor has the same signature as this constructor.&lt;/b&gt;&lt;/p&gt;
 * @param {Object} data (Optional) An object, the properties of which provide values for the new Record's
 * fields. If not specified the &lt;code&gt;{@link Ext.data.Field#defaultValue defaultValue}&lt;/code&gt;
 * for each field will be assigned.
 * @param {Object} id (Optional) The id of the Record. The id is used by the
 * {@link Ext.data.Store} object which owns the Record to index its collection
 * of Records (therefore this id should be unique within each store). If an
 * &lt;code&gt;id&lt;/code&gt; is not specified a &lt;b&gt;&lt;code&gt;{@link #phantom}&lt;/code&gt;&lt;/b&gt;
 * Record will be created with an {@link #Record.id automatically generated id}.
 */
Ext.data.Record = function(data, id){
    // if no id, call the auto id method
    this.id = (id || id === 0) ? id : Ext.data.Record.id(this);
    this.data = data || {};
};

<span id='Ext-data-Record-static-method-create'>/**
</span> * Generate a constructor for a specific Record layout.
 * @param {Array} o An Array of &lt;b&gt;{@link Ext.data.Field Field}&lt;/b&gt; definition objects.
 * The constructor generated by this method may be used to create new Record instances. The data
 * object must contain properties named after the {@link Ext.data.Field field}
 * &lt;b&gt;&lt;tt&gt;{@link Ext.data.Field#name}s&lt;/tt&gt;&lt;/b&gt;.  Example usage:&lt;pre&gt;&lt;code&gt;
// create a Record constructor from a description of the fields
var TopicRecord = Ext.data.Record.create([ // creates a subclass of Ext.data.Record
    {{@link Ext.data.Field#name name}: 'title', {@link Ext.data.Field#mapping mapping}: 'topic_title'},
    {name: 'author', mapping: 'username', allowBlank: false},
    {name: 'totalPosts', mapping: 'topic_replies', type: 'int'},
    {name: 'lastPost', mapping: 'post_time', type: 'date'},
    {name: 'lastPoster', mapping: 'user2'},
    {name: 'excerpt', mapping: 'post_text', allowBlank: false},
    // In the simplest case, if no properties other than &lt;tt&gt;name&lt;/tt&gt; are required,
    // a field definition may consist of just a String for the field name.
    'signature'
]);

// create Record instance
var myNewRecord = new TopicRecord(
    {
        title: 'Do my job please',
        author: 'noobie',
        totalPosts: 1,
        lastPost: new Date(),
        lastPoster: 'Animal',
        excerpt: 'No way dude!',
        signature: ''
    },
    id // optionally specify the id of the record otherwise {@link #Record.id one is auto-assigned}
);
myStore.{@link Ext.data.Store#add add}(myNewRecord);
&lt;/code&gt;&lt;/pre&gt;
 * @method create
 * @return {Function} A constructor which is used to create new Records according
 * to the definition. The constructor has the same signature as {@link #Record}.
 * @static
 */
Ext.data.Record.create = function(o){
    var f = Ext.extend(Ext.data.Record, {});
    var p = f.prototype;
    p.fields = new Ext.util.MixedCollection(false, function(field){
        return field.name;
    });
    for(var i = 0, len = o.length; i &lt; len; i++){
        p.fields.add(new Ext.data.Field(o[i]));
    }
    f.getField = function(name){
        return p.fields.get(name);
    };
    return f;
};

Ext.data.Record.PREFIX = 'ext-record';
Ext.data.Record.AUTO_ID = 1;
Ext.data.Record.EDIT = 'edit';
Ext.data.Record.REJECT = 'reject';
Ext.data.Record.COMMIT = 'commit';


<span id='Ext-data-Record-method-id'>/**
</span> * Generates a sequential id. This method is typically called when a record is {@link #create}d
 * and {@link #Record no id has been specified}. The returned id takes the form:
 * &lt;tt&gt;&amp;#123;PREFIX}-&amp;#123;AUTO_ID}&lt;/tt&gt;.&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;&lt;tt&gt;PREFIX&lt;/tt&gt;&lt;/b&gt; : String&lt;p class=&quot;sub-desc&quot;&gt;&lt;tt&gt;Ext.data.Record.PREFIX&lt;/tt&gt;
 * (defaults to &lt;tt&gt;'ext-record'&lt;/tt&gt;)&lt;/p&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;&lt;tt&gt;AUTO_ID&lt;/tt&gt;&lt;/b&gt; : String&lt;p class=&quot;sub-desc&quot;&gt;&lt;tt&gt;Ext.data.Record.AUTO_ID&lt;/tt&gt;
 * (defaults to &lt;tt&gt;1&lt;/tt&gt; initially)&lt;/p&gt;&lt;/li&gt;
 * &lt;/ul&gt;&lt;/div&gt;
 * @param {Record} rec The record being created.  The record does not exist, it's a {@link #phantom}.
 * @return {String} auto-generated string id, &lt;tt&gt;&quot;ext-record-i++'&lt;/tt&gt;;
 */
Ext.data.Record.id = function(rec) {
    rec.phantom = true;
    return [Ext.data.Record.PREFIX, '-', Ext.data.Record.AUTO_ID++].join('');
};

Ext.data.Record.prototype = {
<span id='Ext-data-Record-property-fields'>    /**
</span>     * &lt;p&gt;&lt;b&gt;This property is stored in the Record definition's &lt;u&gt;prototype&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;
     * A MixedCollection containing the defined {@link Ext.data.Field Field}s for this Record.  Read-only.
     * @property fields
     * @type Ext.util.MixedCollection
     */
<span id='Ext-data-Record-property-data'>    /**
</span>     * An object hash representing the data for this Record. Every field name in the Record definition
     * is represented by a property of that name in this object. Note that unless you specified a field
     * with {@link Ext.data.Field#name name} &quot;id&quot; in the Record definition, this will &lt;b&gt;not&lt;/b&gt; contain
     * an &lt;tt&gt;id&lt;/tt&gt; property.
     * @property data
     * @type {Object}
     */
<span id='Ext-data-Record-property-id'>    /**
</span>     * The unique ID of the Record {@link #Record as specified at construction time}.
     * @property id
     * @type {Object}
     */
<span id='Ext-data-Record-property-node'>    /**
</span>     * &lt;p&gt;&lt;b&gt;Only present if this Record was created by an {@link Ext.data.XmlReader XmlReader}&lt;/b&gt;.&lt;/p&gt;
     * &lt;p&gt;The XML element which was the source of the data for this Record.&lt;/p&gt;
     * @property node
     * @type {XMLElement}
     */
<span id='Ext-data-Record-property-json'>    /**
</span>     * &lt;p&gt;&lt;b&gt;Only present if this Record was created by an {@link Ext.data.ArrayReader ArrayReader} or a {@link Ext.data.JsonReader JsonReader}&lt;/b&gt;.&lt;/p&gt;
     * &lt;p&gt;The Array or object which was the source of the data for this Record.&lt;/p&gt;
     * @property json
     * @type {Array|Object}
     */
<span id='Ext-data-Record-property-dirty'>    /**
</span>     * Readonly flag - true if this Record has been modified.
     * @type Boolean
     */
    dirty : false,
    editing : false,
    error : null,
<span id='Ext-data-Record-property-modified'>    /**
</span>     * This object contains a key and value storing the original values of all modified
     * fields or is null if no fields have been modified.
     * @property modified
     * @type {Object}
     */
    modified : null,
<span id='Ext-data-Record-property-phantom'>    /**
</span>     * &lt;tt&gt;true&lt;/tt&gt; when the record does not yet exist in a server-side database (see
     * {@link #markDirty}).  Any record which has a real database pk set as its id property
     * is NOT a phantom -- it's real.
     * @property phantom
     * @type {Boolean}
     */
    phantom : false,

    // private
    join : function(store){
<span id='Ext-data-Record-property-store'>        /**
</span>         * The {@link Ext.data.Store} to which this Record belongs.
         * @property store
         * @type {Ext.data.Store}
         */
        this.store = store;
    },

<span id='Ext-data-Record-method-set'>    /**
</span>     * Set the {@link Ext.data.Field#name named field} to the specified value.  For example:
     * &lt;pre&gt;&lt;code&gt;
// record has a field named 'firstname'
var Employee = Ext.data.Record.{@link #create}([
    {name: 'firstname'},
    ...
]);

// update the 2nd record in the store:
var rec = myStore.{@link Ext.data.Store#getAt getAt}(1);

// set the value (shows dirty flag):
rec.set('firstname', 'Betty');

// commit the change (removes dirty flag):
rec.{@link #commit}();

// update the record in the store, bypass setting dirty flag,
// and do not store the change in the {@link Ext.data.Store#getModifiedRecords modified records}
rec.{@link #data}['firstname'] = 'Wilma'; // updates record, but not the view
rec.{@link #commit}(); // updates the view
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;b&gt;Notes&lt;/b&gt;:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;If the store has a writer and &lt;code&gt;autoSave=true&lt;/code&gt;, each set()
     * will execute an XHR to the server.&lt;/li&gt;
     * &lt;li&gt;Use &lt;code&gt;{@link #beginEdit}&lt;/code&gt; to prevent the store's &lt;code&gt;update&lt;/code&gt;
     * event firing while using set().&lt;/li&gt;
     * &lt;li&gt;Use &lt;code&gt;{@link #endEdit}&lt;/code&gt; to have the store's &lt;code&gt;update&lt;/code&gt;
     * event fire.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @param {String} name The {@link Ext.data.Field#name name of the field} to set.
     * @param {String/Object/Array} value The value to set the field to.
     */
    set : function(name, value){
        var encode = Ext.isPrimitive(value) ? String : Ext.encode;
        if(encode(this.data[name]) == encode(value)) {
            return;
        }        
        this.dirty = true;
        if(!this.modified){
            this.modified = {};
        }
        if(this.modified[name] === undefined){
            this.modified[name] = this.data[name];
        }
        this.data[name] = value;
        if(!this.editing){
            this.afterEdit();
        }
    },

    // private
    afterEdit : function(){
        if (this.store != undefined &amp;&amp; typeof this.store.afterEdit == &quot;function&quot;) {
            this.store.afterEdit(this);
        }
    },

    // private
    afterReject : function(){
        if(this.store){
            this.store.afterReject(this);
        }
    },

    // private
    afterCommit : function(){
        if(this.store){
            this.store.afterCommit(this);
        }
    },

<span id='Ext-data-Record-method-get'>    /**
</span>     * Get the value of the {@link Ext.data.Field#name named field}.
     * @param {String} name The {@link Ext.data.Field#name name of the field} to get the value of.
     * @return {Object} The value of the field.
     */
    get : function(name){
        return this.data[name];
    },

<span id='Ext-data-Record-method-beginEdit'>    /**
</span>     * Begin an edit. While in edit mode, no events (e.g.. the &lt;code&gt;update&lt;/code&gt; event)
     * are relayed to the containing store.
     * See also: &lt;code&gt;{@link #endEdit}&lt;/code&gt; and &lt;code&gt;{@link #cancelEdit}&lt;/code&gt;.
     */
    beginEdit : function(){
        this.editing = true;
        this.modified = this.modified || {};
    },

<span id='Ext-data-Record-method-cancelEdit'>    /**
</span>     * Cancels all changes made in the current edit operation.
     */
    cancelEdit : function(){
        this.editing = false;
        delete this.modified;
    },

<span id='Ext-data-Record-method-endEdit'>    /**
</span>     * End an edit. If any data was modified, the containing store is notified
     * (ie, the store's &lt;code&gt;update&lt;/code&gt; event will fire).
     */
    endEdit : function(){
        this.editing = false;
        if(this.dirty){
            this.afterEdit();
        }
    },

<span id='Ext-data-Record-method-reject'>    /**
</span>     * Usually called by the {@link Ext.data.Store} which owns the Record.
     * Rejects all changes made to the Record since either creation, or the last commit operation.
     * Modified fields are reverted to their original values.
     * &lt;p&gt;Developers should subscribe to the {@link Ext.data.Store#update} event
     * to have their code notified of reject operations.&lt;/p&gt;
     * @param {Boolean} silent (optional) True to skip notification of the owning
     * store of the change (defaults to false)
     */
    reject : function(silent){
        var m = this.modified;
        for(var n in m){
            if(typeof m[n] != &quot;function&quot;){
                this.data[n] = m[n];
            }
        }
        this.dirty = false;
        delete this.modified;
        this.editing = false;
        if(silent !== true){
            this.afterReject();
        }
    },

<span id='Ext-data-Record-method-commit'>    /**
</span>     * Usually called by the {@link Ext.data.Store} which owns the Record.
     * Commits all changes made to the Record since either creation, or the last commit operation.
     * &lt;p&gt;Developers should subscribe to the {@link Ext.data.Store#update} event
     * to have their code notified of commit operations.&lt;/p&gt;
     * @param {Boolean} silent (optional) True to skip notification of the owning
     * store of the change (defaults to false)
     */
    commit : function(silent){
        this.dirty = false;
        delete this.modified;
        this.editing = false;
        if(silent !== true){
            this.afterCommit();
        }
    },

<span id='Ext-data-Record-method-getChanges'>    /**
</span>     * Gets a hash of only the fields that have been modified since this Record was created or commited.
     * @return Object
     */
    getChanges : function(){
        var m = this.modified, cs = {};
        for(var n in m){
            if(m.hasOwnProperty(n)){
                cs[n] = this.data[n];
            }
        }
        return cs;
    },

    // private
    hasError : function(){
        return this.error !== null;
    },

    // private
    clearError : function(){
        this.error = null;
    },

<span id='Ext-data-Record-method-copy'>    /**
</span>     * Creates a copy (clone) of this Record.
     * @param {String} id (optional) A new Record id, defaults to the id
     * of the record being copied. See &lt;code&gt;{@link #id}&lt;/code&gt;. 
     * To generate a phantom record with a new id use:&lt;pre&gt;&lt;code&gt;
var rec = record.copy(); // clone the record
Ext.data.Record.id(rec); // automatically generate a unique sequential id
     * &lt;/code&gt;&lt;/pre&gt;
     * @return {Record}
     */
    copy : function(newId) {
        return new this.constructor(Ext.apply({}, this.data), newId || this.id);
    },

<span id='Ext-data-Record-method-isModified'>    /**
</span>     * Returns &lt;tt&gt;true&lt;/tt&gt; if the passed field name has been &lt;code&gt;{@link #modified}&lt;/code&gt;
     * since the load or last commit.
     * @param {String} fieldName {@link Ext.data.Field.{@link Ext.data.Field#name}
     * @return {Boolean}
     */
    isModified : function(fieldName){
        return !!(this.modified &amp;&amp; this.modified.hasOwnProperty(fieldName));
    },

<span id='Ext-data-Record-method-isValid'>    /**
</span>     * By default returns &lt;tt&gt;false&lt;/tt&gt; if any {@link Ext.data.Field field} within the
     * record configured with &lt;tt&gt;{@link Ext.data.Field#allowBlank} = false&lt;/tt&gt; returns
     * &lt;tt&gt;true&lt;/tt&gt; from an {@link Ext}.{@link Ext#isEmpty isempty} test.
     * @return {Boolean}
     */
    isValid : function() {
        return this.fields.find(function(f) {
            return (f.allowBlank === false &amp;&amp; Ext.isEmpty(this.data[f.name])) ? true : false;
        },this) ? false : true;
    },

<span id='Ext-data-Record-method-markDirty'>    /**
</span>     * &lt;p&gt;Marks this &lt;b&gt;Record&lt;/b&gt; as &lt;code&gt;{@link #dirty}&lt;/code&gt;.  This method
     * is used interally when adding &lt;code&gt;{@link #phantom}&lt;/code&gt; records to a
     * {@link Ext.data.Store#writer writer enabled store}.&lt;/p&gt;
     * &lt;br&gt;&lt;p&gt;Marking a record &lt;code&gt;{@link #dirty}&lt;/code&gt; causes the phantom to
     * be returned by {@link Ext.data.Store#getModifiedRecords} where it will
     * have a create action composed for it during {@link Ext.data.Store#save store save}
     * operations.&lt;/p&gt;
     */
    markDirty : function(){
        this.dirty = true;
        if(!this.modified){
            this.modified = {};
        }
        this.fields.each(function(f) {
            this.modified[f.name] = this.data[f.name];
        },this);
    }
};
</pre>
</body>
</html>
