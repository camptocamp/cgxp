<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// for old browsers
window.undefined = window.undefined;

<span id='Ext'>/**
</span> * @class Ext
 * Ext core utilities and functions.
 * @singleton
 */

Ext = {
<span id='Ext-property-version'>    /**
</span>     * The version of the framework
     * @type String
     */
    version : '3.4.1.1',
<span id='Ext-property-versionDetail'>    versionDetail : {
</span>        major : 3,
        minor : 4,
        patch : 1.1
    }
};

<span id='Ext-method-apply'>/**
</span> * Copies all the properties of config to obj.
 * @param {Object} obj The receiver of the properties
 * @param {Object} config The source of the properties
 * @param {Object} defaults A different object that will also be applied for default values
 * @return {Object} returns obj
 * @member Ext apply
 */
Ext.apply = function(o, c, defaults){
    // no &quot;this&quot; reference for friendly out of scope calls
    if(defaults){
        Ext.apply(o, defaults);
    }
    if(o &amp;&amp; c &amp;&amp; typeof c == 'object'){
        for(var p in c){
            o[p] = c[p];
        }
    }
    return o;
};

(function(){
    var idSeed = 0,
        toString = Object.prototype.toString,
        ua = navigator.userAgent.toLowerCase(),
        check = function(r){
            return r.test(ua);
        },
        DOC = document,
        docMode = DOC.documentMode,
        isStrict = DOC.compatMode == &quot;CSS1Compat&quot;,
        isOpera = check(/opera/),
        isChrome = check(/\bchrome\b/),
        isWebKit = check(/webkit/),
        isSafari = !isChrome &amp;&amp; check(/safari/),
        isSafari2 = isSafari &amp;&amp; check(/applewebkit\/4/), // unique to Safari 2
        isSafari3 = isSafari &amp;&amp; check(/version\/3/),
        isSafari4 = isSafari &amp;&amp; check(/version\/4/),
        isIE = !isOpera &amp;&amp; check(/msie/),
        isIE7 = isIE &amp;&amp; ((check(/msie 7/) &amp;&amp; docMode != 8 &amp;&amp; docMode != 9 &amp;&amp; docMode != 10) || docMode == 7),
        isIE8 = isIE &amp;&amp; ((check(/msie 8/) &amp;&amp; docMode != 7 &amp;&amp; docMode != 9 &amp;&amp; docMode != 10) || docMode == 8),
        isIE9 = isIE &amp;&amp; ((check(/msie 9/) &amp;&amp; docMode != 7 &amp;&amp; docMode != 8 &amp;&amp; docMode != 10) || docMode == 9),
        isIE10 = isIE &amp;&amp; ((check(/msie 10/) &amp;&amp; docMode != 7 &amp;&amp; docMode != 8 &amp;&amp; docMode != 9) || docMode == 10),
        isIE6 = isIE &amp;&amp; check(/msie 6/),
        isIE9m = isIE &amp;&amp; (isIE6 || isIE7 || isIE8 || isIE9),
        isGecko = !isWebKit &amp;&amp; check(/gecko/),
        isGecko2 = isGecko &amp;&amp; check(/rv:1\.8/),
        isGecko3 = isGecko &amp;&amp; check(/rv:1\.9/),
        isBorderBox = isIE9m &amp;&amp; !isStrict,
        isWindows = check(/windows|win32/),
        isMac = check(/macintosh|mac os x/),
        isAir = check(/adobeair/),
        isLinux = check(/linux/),
        isSecure = /^https/i.test(window.location.protocol),
        noArgs = [],
        nonEnumerables = [],
        emptyFn = Ext.emptyFn,
        t = Ext.apply({}, {
            constructor: emptyFn,
            toString: emptyFn,
            valueOf: emptyFn
        }),
        callOverrideParent = function () {
            var method = callOverrideParent.caller.caller; // skip callParent (our caller)
            return method.$owner.prototype[method.$name].apply(this, arguments);
        };

    if (t.constructor !== emptyFn) {
        nonEnumerables.push('constructor');
    }
    if (t.toString !== emptyFn) {
        nonEnumerables.push('toString');
    }
    if (t.valueOf !== emptyFn) {
        nonEnumerables.push('valueOf');
    }
    if (!nonEnumerables.length) {
        nonEnumerables = null;
    }

    // Create the abstract Base class to provide an empty constructor and callParent implementations
    function Base () {
        //
    }

    Ext.apply(Base, {
        $isClass: true,

        callParent: function (args) {
            var method;

            // This code is intentionally inlined for the least number of debugger stepping
            return (method = this.callParent.caller) &amp;&amp; (method.$previous ||
                ((method = method.$owner ? method : method.caller) &amp;&amp;
                        method.$owner.superclass.self[method.$name])).apply(this, args || noArgs);
        }
    });

    Base.prototype = {
        constructor: function() {
        },
        callParent: function(args) {
            // NOTE: this code is deliberately as few expressions (and no function calls)
            // as possible so that a debugger can skip over this noise with the minimum number
            // of steps. Basically, just hit Step Into until you are where you really wanted
            // to be.
            var method,
                superMethod = (method = this.callParent.caller) &amp;&amp; (method.$previous ||
                        ((method = method.$owner ? method : method.caller) &amp;&amp;
                                method.$owner.superclass[method.$name]));

            return superMethod.apply(this, args || noArgs);
        }
    };

    // remove css image flicker
    if(isIE6){
        try{
            DOC.execCommand(&quot;BackgroundImageCache&quot;, false, true);
        }catch(e){}
    }

    Ext.apply(Ext, {
<span id='Ext-property-SSL_SECURE_URL'>        /**
</span>         * URL to a blank file used by Ext when in secure mode for iframe src and onReady src to prevent
         * the IE insecure content warning (&lt;tt&gt;'about:blank'&lt;/tt&gt;, except for IE in secure mode, which is &lt;tt&gt;'javascript:&quot;&quot;'&lt;/tt&gt;).
         * @type String
         */
        SSL_SECURE_URL : isSecure &amp;&amp; isIE ? 'javascript:&quot;&quot;' : 'about:blank',
<span id='Ext-property-isStrict'>        /**
</span>         * True if the browser is in strict (standards-compliant) mode, as opposed to quirks mode
         * @type Boolean
         */
        isStrict : isStrict,
<span id='Ext-property-isSecure'>        /**
</span>         * True if the page is running over SSL
         * @type Boolean
         */
        isSecure : isSecure,
<span id='Ext-property-isReady'>        /**
</span>         * True when the document is fully initialized and ready for action
         * @type Boolean
         */
        isReady : false,

<span id='Ext-property-enableFx'>        /**
</span>         * True if the {@link Ext.Fx} Class is available
         * @type Boolean
         * @property enableFx
         */

<span id='Ext-property-enableForcedBoxModel'>        /**
</span>         * HIGHLY EXPERIMENTAL
         * True to force css based border-box model override and turning off javascript based adjustments. This is a
         * runtime configuration and must be set before onReady.
         * @type Boolean
         */
        enableForcedBoxModel : false,

<span id='Ext-property-enableGarbageCollector'>        /**
</span>         * True to automatically uncache orphaned Ext.Elements periodically (defaults to true)
         * @type Boolean
         */
        enableGarbageCollector : true,

<span id='Ext-property-enableListenerCollection'>        /**
</span>         * True to automatically purge event listeners during garbageCollection (defaults to false).
         * @type Boolean
         */
        enableListenerCollection : false,

<span id='Ext-property-enableNestedListenerRemoval'>        /**
</span>         * EXPERIMENTAL - True to cascade listener removal to child elements when an element is removed.
         * Currently not optimized for performance.
         * @type Boolean
         */
        enableNestedListenerRemoval : false,

<span id='Ext-property-USE_NATIVE_JSON'>        /**
</span>         * Indicates whether to use native browser parsing for JSON methods.
         * This option is ignored if the browser does not support native JSON methods.
         * &lt;b&gt;Note: Native JSON methods will not work with objects that have functions.
         * Also, property names must be quoted, otherwise the data will not parse.&lt;/b&gt; (Defaults to false)
         * @type Boolean
         */
        USE_NATIVE_JSON : false,

<span id='Ext-method-applyIf'>        /**
</span>         * Copies all the properties of config to obj if they don't already exist.
         * @param {Object} obj The receiver of the properties
         * @param {Object} config The source of the properties
         * @return {Object} returns obj
         */
        applyIf : function(o, c){
            if(o){
                for(var p in c){
                    if(!Ext.isDefined(o[p])){
                        o[p] = c[p];
                    }
                }
            }
            return o;
        },

<span id='Ext-method-id'>        /**
</span>         * Generates unique ids. If the element already has an id, it is unchanged
         * @param {Mixed} el (optional) The element to generate an id for
         * @param {String} prefix (optional) Id prefix (defaults &quot;ext-gen&quot;)
         * @return {String} The generated Id.
         */
        id : function(el, prefix){
            el = Ext.getDom(el, true) || {};
            if (!el.id) {
                el.id = (prefix || &quot;ext-gen&quot;) + (++idSeed);
            }
            return el.id;
        },

<span id='Ext-method-extend'>        /**
</span>         * &lt;p&gt;Extends one class to create a subclass and optionally overrides members with the passed literal. This method
         * also adds the function &quot;override()&quot; to the subclass that can be used to override members of the class.&lt;/p&gt;
         * For example, to create a subclass of Ext GridPanel:
         * &lt;pre&gt;&lt;code&gt;
MyGridPanel = Ext.extend(Ext.grid.GridPanel, {
    constructor: function(config) {

//      Create configuration for this Grid.
        var store = new Ext.data.Store({...});
        var colModel = new Ext.grid.ColumnModel({...});

//      Create a new config object containing our computed properties
//      *plus* whatever was in the config parameter.
        config = Ext.apply({
            store: store,
            colModel: colModel
        }, config);

        MyGridPanel.superclass.constructor.call(this, config);

//      Your postprocessing here
    },

    yourMethod: function() {
        // etc.
    }
});
&lt;/code&gt;&lt;/pre&gt;
         *
         * &lt;p&gt;This function also supports a 3-argument call in which the subclass's constructor is
         * passed as an argument. In this form, the parameters are as follows:&lt;/p&gt;
         * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;&lt;code&gt;subclass&lt;/code&gt; : Function &lt;div class=&quot;sub-desc&quot;&gt;The subclass constructor.&lt;/div&gt;&lt;/li&gt;
         * &lt;li&gt;&lt;code&gt;superclass&lt;/code&gt; : Function &lt;div class=&quot;sub-desc&quot;&gt;The constructor of class being extended&lt;/div&gt;&lt;/li&gt;
         * &lt;li&gt;&lt;code&gt;overrides&lt;/code&gt; : Object &lt;div class=&quot;sub-desc&quot;&gt;A literal with members which are copied into the subclass's
         * prototype, and are therefore shared among all instances of the new class.&lt;/div&gt;&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         *
         * @param {Function} superclass The constructor of class being extended.
         * @param {Object} overrides &lt;p&gt;A literal with members which are copied into the subclass's
         * prototype, and are therefore shared between all instances of the new class.&lt;/p&gt;
         * &lt;p&gt;This may contain a special member named &lt;tt&gt;&lt;b&gt;constructor&lt;/b&gt;&lt;/tt&gt;. This is used
         * to define the constructor of the new class, and is returned. If this property is
         * &lt;i&gt;not&lt;/i&gt; specified, a constructor is generated and returned which just calls the
         * superclass's constructor passing on its parameters.&lt;/p&gt;
         * &lt;p&gt;&lt;b&gt;It is essential that you call the superclass constructor in any provided constructor. See example code.&lt;/b&gt;&lt;/p&gt;
         * @return {Function} The subclass constructor from the &lt;code&gt;overrides&lt;/code&gt; parameter, or a generated one if not provided.
         */
        extend : function(){
            // inline overrides
            var io = function(o){
                for(var m in o){
                    this[m] = o[m];
                }
            };
            var oc = Object.prototype.constructor;

            return function(sb, sp, overrides){
                if(typeof sp == 'object'){
                    overrides = sp;
                    sp = sb;
                    sb = overrides.constructor != oc ? overrides.constructor : function(){sp.apply(this, arguments);};
                }
                var F = function(){},
                    sbp,
                    spp = sp.prototype;

                F.prototype = spp;
                sbp = sb.prototype = new F();
                sbp.constructor=sb;
                sb.superclass=spp;
                if(spp.constructor == oc){
                    spp.constructor=sp;
                }
                sb.override = function(o){
                    Ext.override(sb, o);
                };
                sbp.superclass = sbp.supr = (function(){
                    return spp;
                });
                sbp.override = io;
                Ext.override(sb, overrides);
                sb.extend = function(o){return Ext.extend(sb, o);};
                return sb;
            };
        }(),

        global: (function () {
            return this;
        })(),

        Base: Base,

        namespaceCache: {},

        createNamespace: function (namespaceOrClass, isClass) {
            var cache = Ext.namespaceCache,
                namespace = isClass ? namespaceOrClass.substring(0, namespaceOrClass.lastIndexOf('.'))
                            : namespaceOrClass,
                ns = cache[namespace],
                i, n, part, parts, partials;

            if (!ns) {
                ns = Ext.global;
                if (namespace) {
                    partials = [];
                    parts = namespace.split('.');

                    for (i = 0, n = parts.length; i &lt; n; ++i) {
                        part = parts[i];

                        ns = ns[part] || (ns[part] = {});
                        partials.push(part);

                        cache[partials.join('.')] = ns; // build up prefixes as we go
                    }
                }
            }

            return ns;
        },

        getClassByName: function (className) {
            var parts = className.split('.'),
                cls = Ext.global,
                n = parts.length,
                i;

            for (i = 0; cls &amp;&amp; i &lt; n; ++i) {
                cls = cls[parts[i]];
            }

            return cls || null;
        },

        addMembers: function (cls, target, members, handleNonEnumerables) {
            var i, name, member;

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];
                    if (typeof member == 'function') {
                        member.$owner = cls;
                        member.$name = name;
                    }

                    target[name] = member;
                }
            }

            if (handleNonEnumerables &amp;&amp; nonEnumerables) {
                for (i = nonEnumerables.length; i-- &gt; 0; ) {
                    name = nonEnumerables[i];
                    if (members.hasOwnProperty(name)) {
                        member = members[name];
                        if (typeof member == 'function') {
                            member.$owner = cls;
                            member.$name = name;
                        }

                        target[name] = member;
                    }
                }
            }
        },

<span id='Ext-method-define'>        /**
</span>         * @method
         * Defines a class or override. A basic class is defined like this:
         *
         *      Ext.define('My.awesome.Class', {
         *          someProperty: 'something',
         *
         *          someMethod: function(s) {
         *              alert(s + this.someProperty);
         *          }
         *
         *          ...
         *      });
         *
         *      var obj = new My.awesome.Class();
         *
         *      obj.someMethod('Say '); // alerts 'Say something'
         *
         * To create an anonymous class, pass `null` for the `className`:
         * 
         *      Ext.define(null, {
         *          constructor: function () {
         *              // ...
         *          }
         *      });
         *
         * In some cases, it is helpful to create a nested scope to contain some private
         * properties. The best way to do this is to pass a function instead of an object
         * as the second parameter. This function will be called to produce the class
         * body:
         * 
         *      Ext.define('MyApp.foo.Bar', function () {
         *          var id = 0;
         *          
         *          return {
         *              nextId: function () {
         *                  return ++id;
         *              }
         *          };
         *      });
         * 
         * When using this form of `Ext.define`, the function is passed a reference to its
         * class. This can be used as an efficient way to access any static properties you
         * may have:
         * 
         *      Ext.define('MyApp.foo.Bar', function (Bar) {
         *          return {
         *              statics: {
         *                  staticMethod: function () {
         *                      // ...
         *                  }
         *              },
         *              
         *              method: function () {
         *                  return Bar.staticMethod();
         *              }
         *          };
         *      });
         *
         * To define an override, include the `override` property. The content of an
         * override is aggregated with the specified class in order to extend or modify
         * that class. This can be as simple as setting default property values or it can
         * extend and/or replace methods. This can also extend the statics of the class.
         *
         * One use for an override is to break a large class into manageable pieces.
         *
         *      // File: /src/app/Panel.js
         *
         *      Ext.define('My.app.Panel', {
         *          extend: 'Ext.panel.Panel',
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls Ext.panel.Panel's constructor
         *              //...
         *          },
         *
         *          statics: {
         *              method: function () {
         *                  return 'abc';
         *              }
         *          }
         *      });
         *
         *      // File: /src/app/PanelPart2.js
         *      Ext.define('My.app.PanelPart2', {
         *          override: 'My.app.Panel',
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls My.app.Panel's constructor
         *              //...
         *          }
         *      });
         *
         * Another use of overrides is to provide optional parts of classes that can be
         * independently required. In this case, the class may even be unaware of the
         * override altogether.
         *
         *      Ext.define('My.ux.CoolTip', {
         *          override: 'Ext.tip.ToolTip',
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls Ext.tip.ToolTip's constructor
         *              //...
         *          }
         *      });
         *
         * Overrides can also contain statics:
         *
         *      Ext.define('My.app.BarMod', {
         *          override: 'Ext.foo.Bar',
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x * 2]); // call Ext.foo.Bar.method
         *              }
         *          }
         *      });
         *
         * @param {String} className The class name to create in string dot-namespaced format, for example:
         * 'My.very.awesome.Class', 'FeedViewer.plugin.CoolPager'
         * It is highly recommended to follow this simple convention:
         *  - The root and the class name are 'CamelCased'
         *  - Everything else is lower-cased
         * Pass `null` to create an anonymous class.
         * @param {Object} data The key - value pairs of properties to apply to this class. Property names can be of any valid
         * strings, except those in the reserved listed below:
         *  - `mixins`
         *  - `statics`
         *  - `config`
         *  - `alias`
         *  - `self`
         *  - `singleton`
         *  - `alternateClassName`
         *  - `override`
         *
         * @param {Function} createdFn Optional callback to execute after the class is created, the execution scope of which
         * (`this`) will be the newly created class itself.
         * @return {Ext.Base}
         * @markdown
         * @member Ext
         * @method define
         */
        define: function (className, body, createdFn) {
            var override = body.override,
                cls, extend, name, namespace;

            if (override) {
                delete body.override;
                cls = Ext.getClassByName(override);
                Ext.override(cls, body);
            } else {
                if (className) {
                    namespace = Ext.createNamespace(className, true);
                    name = className.substring(className.lastIndexOf('.')+1);
                }

                cls = function ctor () {
                    this.constructor.apply(this, arguments);
                }

                if (className) {
                    cls.displayName = className;
                }
                cls.$isClass = true;
                cls.callParent = Ext.Base.callParent;

                if (typeof body == 'function') {
                    body = body(cls);
                }

                extend = body.extend;
                if (extend) {
                    delete body.extend;
                    if (typeof extend == 'string') {
                        extend = Ext.getClassByName(extend);
                    }
                } else {
                    extend = Base;
                }

                Ext.extend(cls, extend, body);
                if (cls.prototype.constructor === cls) {
                    delete cls.prototype.constructor;
                }

                // Not extending a class which derives from Base...
                if (!cls.prototype.$isClass) {
                    Ext.applyIf(cls.prototype, Base.prototype);
                }
                cls.prototype.self = cls;
                
                if (body.xtype) {
                    Ext.reg(body.xtype, cls);
                }
                cls = body.singleton ? new cls() : cls;
                if (className) {
                    namespace[name] = cls;
                }
            }

            if (createdFn) {
                createdFn.call(cls);
            }

            return cls;
        },

<span id='Ext-method-override'>        /**
</span>         * Overrides members of the specified `target` with the given values.
         *
         * If the `target` is a function, it is assumed to be a constructor and the contents
         * of `overrides` are applied to its `prototype` using {@link Ext#apply Ext.apply}.
         * 
         * If the `target` is an instance of a class created using {@link #define},
         * the `overrides` are applied to only that instance. In this case, methods are
         * specially processed to allow them to use {@link Ext.Base#callParent}.
         * 
         *      var panel = new Ext.Panel({ ... });
         *      
         *      Ext.override(panel, {
         *          initComponent: function () {
         *              // extra processing...
         *              
         *              this.callParent();
         *          }
         *      });
         *
         * If the `target` is none of these, the `overrides` are applied to the `target`
         * using {@link Ext#apply Ext.apply}.
         *
         * Please refer to {@link Ext#define Ext.define} for further details.
         *
         * @param {Object} target The target to override.
         * @param {Object} overrides The properties to add or replace on `target`. 
         * @method override
         */
        override: function (target, overrides) {
            var proto, statics;

            if (overrides) {
                if (target.$isClass) {
                    statics = overrides.statics;
                    if (statics) {
                        delete overrides.statics;
                    }

                    Ext.addMembers(target, target.prototype, overrides, true);
                    if (statics) {
                        Ext.addMembers(target, target, statics);
                    }
                } else if (typeof target == 'function') {
                    proto = target.prototype;
                    Ext.apply(proto, overrides);
                    if(Ext.isIE &amp;&amp; overrides.hasOwnProperty('toString')){
                        proto.toString = overrides.toString;
                    }
                } else {
                    var owner = target.self,
                        name, value;

                    if (owner &amp;&amp; owner.$isClass) {
                        for (name in overrides) {
                            if (overrides.hasOwnProperty(name)) {
                                value = overrides[name];

                                if (typeof value == 'function') {
                                    //&lt;debug&gt;
                                    if (owner.$className) {
                                        value.displayName = owner.$className + '#' + name;
                                    }
                                    //&lt;/debug&gt;

                                    value.$name = name;
                                    value.$owner = owner;
                                    value.$previous = target.hasOwnProperty(name)
                                        ? target[name] // already hooked, so call previous hook
                                        : callOverrideParent; // calls by name on prototype
                                }

                                target[name] = value;
                            }
                        }
                    } else {
                        Ext.apply(target, overrides);

                        if (!target.constructor.$isClass) {
                            target.constructor.prototype.callParent = Base.prototype.callParent;
                            target.constructor.callParent = Base.callParent;
                        }
                    }
                }
            }
        },

<span id='Ext-method-namespace'>        /**
</span>         * Creates namespaces to be used for scoping variables and classes so that they are not global.
         * Specifying the last node of a namespace implicitly creates all other nodes. Usage:
         * &lt;pre&gt;&lt;code&gt;
Ext.namespace('Company', 'Company.data');
Ext.namespace('Company.data'); // equivalent and preferable to above syntax
Company.Widget = function() { ... }
Company.data.CustomStore = function(config) { ... }
&lt;/code&gt;&lt;/pre&gt;
         * @param {String} namespace1
         * @param {String} namespace2
         * @param {String} etc
         * @return {Object} The namespace object. (If multiple arguments are passed, this will be the last namespace created)
         * @method namespace
         */
        namespace : function(){
            var len1 = arguments.length,
                i = 0,
                len2,
                j,
                main,
                ns,
                sub,
                current;

            for(; i &lt; len1; ++i) {
                main = arguments[i];
                ns = arguments[i].split('.');
                current = window[ns[0]];
                if (current === undefined) {
                    current = window[ns[0]] = {};
                }
                sub = ns.slice(1);
                len2 = sub.length;
                for(j = 0; j &lt; len2; ++j) {
                    current = current[sub[j]] = current[sub[j]] || {};
                }
            }
            return current;
        },

<span id='Ext-method-urlEncode'>        /**
</span>         * Takes an object and converts it to an encoded URL. e.g. Ext.urlEncode({foo: 1, bar: 2}); would return &quot;foo=1&amp;bar=2&quot;.  Optionally, property values can be arrays, instead of keys and the resulting string that's returned will contain a name/value pair for each array value.
         * @param {Object} o
         * @param {String} pre (optional) A prefix to add to the url encoded string
         * @return {String}
         */
        urlEncode : function(o, pre){
            var empty,
                buf = [],
                e = encodeURIComponent;

            Ext.iterate(o, function(key, item){
                empty = Ext.isEmpty(item);
                Ext.each(empty ? key : item, function(val){
                    buf.push('&amp;', e(key), '=', (!Ext.isEmpty(val) &amp;&amp; (val != key || !empty)) ? (Ext.isDate(val) ? Ext.encode(val).replace(/&quot;/g, '') : e(val)) : '');
                });
            });
            if(!pre){
                buf.shift();
                pre = '';
            }
            return pre + buf.join('');
        },

<span id='Ext-method-urlDecode'>        /**
</span>         * Takes an encoded URL and and converts it to an object. Example: &lt;pre&gt;&lt;code&gt;
Ext.urlDecode(&quot;foo=1&amp;bar=2&quot;); // returns {foo: &quot;1&quot;, bar: &quot;2&quot;}
Ext.urlDecode(&quot;foo=1&amp;bar=2&amp;bar=3&amp;bar=4&quot;, false); // returns {foo: &quot;1&quot;, bar: [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;]}
&lt;/code&gt;&lt;/pre&gt;
         * @param {String} string
         * @param {Boolean} overwrite (optional) Items of the same name will overwrite previous values instead of creating an an array (Defaults to false).
         * @return {Object} A literal with members
         */
        urlDecode : function(string, overwrite){
            if(Ext.isEmpty(string)){
                return {};
            }
            var obj = {},
                pairs = string.split('&amp;'),
                d = decodeURIComponent,
                name,
                value;
            Ext.each(pairs, function(pair) {
                pair = pair.split('=');
                name = d(pair[0]);
                value = d(pair[1]);
                obj[name] = overwrite || !obj[name] ? value :
                            [].concat(obj[name]).concat(value);
            });
            return obj;
        },

<span id='Ext-method-urlAppend'>        /**
</span>         * Appends content to the query string of a URL, handling logic for whether to place
         * a question mark or ampersand.
         * @param {String} url The URL to append to.
         * @param {String} s The content to append to the URL.
         * @return (String) The resulting URL
         */
        urlAppend : function(url, s){
            if(!Ext.isEmpty(s)){
                return url + (url.indexOf('?') === -1 ? '?' : '&amp;') + s;
            }
            return url;
        },

<span id='Ext-method-toArray'>        /**
</span>         * Converts any iterable (numeric indices and a length property) into a true array
         * Don't use this on strings. IE doesn't support &quot;abc&quot;[0] which this implementation depends on.
         * For strings, use this instead: &quot;abc&quot;.match(/./g) =&gt; [a,b,c];
         * @param {Iterable} the iterable object to be turned into a true Array.
         * @return (Array) array
         */
         toArray : function(){
             return isIE ?
                 function(a, i, j, res){
                     res = [];
                     for(var x = 0, len = a.length; x &lt; len; x++) {
                         res.push(a[x]);
                     }
                     return res.slice(i || 0, j || res.length);
                 } :
                 function(a, i, j){
                     return Array.prototype.slice.call(a, i || 0, j || a.length);
                 };
         }(),

        isIterable : function(v){
            //check for array or arguments
            if(Ext.isArray(v) || v.callee){
                return true;
            }
            //check for node list type
            if(/NodeList|HTMLCollection/.test(toString.call(v))){
                return true;
            }
            //NodeList has an item and length property
            //IXMLDOMNodeList has nextNode method, needs to be checked first.
            return ((typeof v.nextNode != 'undefined' || v.item) &amp;&amp; Ext.isNumber(v.length));
        },

<span id='Ext-method-each'>        /**
</span>         * Iterates an array calling the supplied function.
         * @param {Array/NodeList/Mixed} array The array to be iterated. If this
         * argument is not really an array, the supplied function is called once.
         * @param {Function} fn The function to be called with each item. If the
         * supplied function returns false, iteration stops and this method returns
         * the current &lt;code&gt;index&lt;/code&gt;. This function is called with
         * the following arguments:
         * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;&lt;code&gt;item&lt;/code&gt; : &lt;i&gt;Mixed&lt;/i&gt;
         * &lt;div class=&quot;sub-desc&quot;&gt;The item at the current &lt;code&gt;index&lt;/code&gt;
         * in the passed &lt;code&gt;array&lt;/code&gt;&lt;/div&gt;&lt;/li&gt;
         * &lt;li&gt;&lt;code&gt;index&lt;/code&gt; : &lt;i&gt;Number&lt;/i&gt;
         * &lt;div class=&quot;sub-desc&quot;&gt;The current index within the array&lt;/div&gt;&lt;/li&gt;
         * &lt;li&gt;&lt;code&gt;allItems&lt;/code&gt; : &lt;i&gt;Array&lt;/i&gt;
         * &lt;div class=&quot;sub-desc&quot;&gt;The &lt;code&gt;array&lt;/code&gt; passed as the first
         * argument to &lt;code&gt;Ext.each&lt;/code&gt;.&lt;/div&gt;&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Object} scope The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the specified function is executed.
         * Defaults to the &lt;code&gt;item&lt;/code&gt; at the current &lt;code&gt;index&lt;/code&gt;
         * within the passed &lt;code&gt;array&lt;/code&gt;.
         * @return See description for the fn parameter.
         */
        each : function(array, fn, scope){
            if(Ext.isEmpty(array, true)){
                return;
            }
            if(!Ext.isIterable(array) || Ext.isPrimitive(array)){
                array = [array];
            }
            for(var i = 0, len = array.length; i &lt; len; i++){
                if(fn.call(scope || array[i], array[i], i, array) === false){
                    return i;
                };
            }
        },

<span id='Ext-method-iterate'>        /**
</span>         * Iterates either the elements in an array, or each of the properties in an object.
         * &lt;b&gt;Note&lt;/b&gt;: If you are only iterating arrays, it is better to call {@link #each}.
         * @param {Object/Array} object The object or array to be iterated
         * @param {Function} fn The function to be called for each iteration.
         * The iteration will stop if the supplied function returns false, or
         * all array elements / object properties have been covered. The signature
         * varies depending on the type of object being interated:
         * &lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;Arrays : &lt;tt&gt;(Object item, Number index, Array allItems)&lt;/tt&gt;
         * &lt;div class=&quot;sub-desc&quot;&gt;
         * When iterating an array, the supplied function is called with each item.&lt;/div&gt;&lt;/li&gt;
         * &lt;li&gt;Objects : &lt;tt&gt;(String key, Object value, Object)&lt;/tt&gt;
         * &lt;div class=&quot;sub-desc&quot;&gt;
         * When iterating an object, the supplied function is called with each key-value pair in
         * the object, and the iterated object&lt;/div&gt;&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Object} scope The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the specified function is executed. Defaults to
         * the &lt;code&gt;object&lt;/code&gt; being iterated.
         */
        iterate : function(obj, fn, scope){
            if(Ext.isEmpty(obj)){
                return;
            }
            if(Ext.isIterable(obj)){
                Ext.each(obj, fn, scope);
                return;
            }else if(typeof obj == 'object'){
                for(var prop in obj){
                    if(obj.hasOwnProperty(prop)){
                        if(fn.call(scope || obj, prop, obj[prop], obj) === false){
                            return;
                        };
                    }
                }
            }
        },

<span id='Ext-method-getDom'>        /**
</span>         * Return the dom node for the passed String (id), dom node, or Ext.Element.
         * Optional 'strict' flag is needed for IE since it can return 'name' and
         * 'id' elements by using getElementById.
         * Here are some examples:
         * &lt;pre&gt;&lt;code&gt;
// gets dom node based on id
var elDom = Ext.getDom('elId');
// gets dom node based on the dom node
var elDom1 = Ext.getDom(elDom);

// If we don&amp;#39;t know if we are working with an
// Ext.Element or a dom node use Ext.getDom
function(el){
    var dom = Ext.getDom(el);
    // do something with the dom node
}
         * &lt;/code&gt;&lt;/pre&gt;
         * &lt;b&gt;Note&lt;/b&gt;: the dom node to be found actually needs to exist (be rendered, etc)
         * when this method is called to be successful.
         * @param {Mixed} el
         * @return HTMLElement
         */
        getDom : function(el, strict){
            if(!el || !DOC){
                return null;
            }
            if (el.dom){
                return el.dom;
            } else {
                if (typeof el == 'string') {
                    var e = DOC.getElementById(el);
                    // IE returns elements with the 'name' and 'id' attribute.
                    // we do a strict check to return the element with only the id attribute
                    if (e &amp;&amp; isIE &amp;&amp; strict) {
                        if (el == e.getAttribute('id')) {
                            return e;
                        } else {
                            return null;
                        }
                    }
                    return e;
                } else {
                    return el;
                }
            }
        },

<span id='Ext-method-getBody'>        /**
</span>         * Returns the current document body as an {@link Ext.Element}.
         * @return Ext.Element The document body
         */
        getBody : function(){
            return Ext.get(DOC.body || DOC.documentElement);
        },

<span id='Ext-method-getHead'>        /**
</span>         * Returns the current document body as an {@link Ext.Element}.
         * @return Ext.Element The document body
         * @method
         */
        getHead : function() {
            var head;

            return function() {
                if (head == undefined) {
                    head = Ext.get(DOC.getElementsByTagName(&quot;head&quot;)[0]);
                }

                return head;
            };
        }(),

<span id='Ext-method-removeNode'>        /**
</span>         * &lt;p&gt;Removes this element from the document, removes all DOM event listeners, and deletes the cache reference.
         * All DOM event listeners are removed from this element. If {@link Ext#enableNestedListenerRemoval} is
         * &lt;code&gt;true&lt;/code&gt;, then DOM event listeners are also removed from all child nodes. The body node
         * will be ignored if passed in.&lt;/p&gt;
         * @param {HTMLElement} node The node to remove
         * @method
         */
        removeNode : isIE &amp;&amp; !isIE8 ? function(){
            var d;
            return function(n){
                if(n &amp;&amp; n.tagName != 'BODY'){
                    (Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n, true) : Ext.EventManager.removeAll(n);
                    d = d || DOC.createElement('div');
                    d.appendChild(n);
                    d.innerHTML = '';
                    delete Ext.elCache[n.id];
                }
            };
        }() : function(n){
            if(n &amp;&amp; n.parentNode &amp;&amp; n.tagName != 'BODY'){
                (Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n, true) : Ext.EventManager.removeAll(n);
                n.parentNode.removeChild(n);
                delete Ext.elCache[n.id];
            }
        },

<span id='Ext-method-isEmpty'>        /**
</span>         * &lt;p&gt;Returns true if the passed value is empty.&lt;/p&gt;
         * &lt;p&gt;The value is deemed to be empty if it is&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
         * &lt;li&gt;null&lt;/li&gt;
         * &lt;li&gt;undefined&lt;/li&gt;
         * &lt;li&gt;an empty array&lt;/li&gt;
         * &lt;li&gt;a zero length string (Unless the &lt;tt&gt;allowBlank&lt;/tt&gt; parameter is &lt;tt&gt;true&lt;/tt&gt;)&lt;/li&gt;
         * &lt;/ul&gt;&lt;/div&gt;
         * @param {Mixed} value The value to test
         * @param {Boolean} allowBlank (optional) true to allow empty strings (defaults to false)
         * @return {Boolean}
         */
        isEmpty : function(v, allowBlank){
            return v === null || v === undefined || ((Ext.isArray(v) &amp;&amp; !v.length)) || (!allowBlank ? v === '' : false);
        },

<span id='Ext-method-isArray'>        /**
</span>         * Returns true if the passed value is a JavaScript array, otherwise false.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isArray : function(v){
            return toString.apply(v) === '[object Array]';
        },

<span id='Ext-method-isDate'>        /**
</span>         * Returns true if the passed object is a JavaScript date object, otherwise false.
         * @param {Object} object The object to test
         * @return {Boolean}
         */
        isDate : function(v){
            return toString.apply(v) === '[object Date]';
        },

<span id='Ext-method-isObject'>        /**
</span>         * Returns true if the passed value is a JavaScript Object, otherwise false.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isObject : function(v){
            return !!v &amp;&amp; Object.prototype.toString.call(v) === '[object Object]';
        },

<span id='Ext-method-isPrimitive'>        /**
</span>         * Returns true if the passed value is a JavaScript 'primitive', a string, number or boolean.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isPrimitive : function(v){
            return Ext.isString(v) || Ext.isNumber(v) || Ext.isBoolean(v);
        },

<span id='Ext-method-isFunction'>        /**
</span>         * Returns true if the passed value is a JavaScript Function, otherwise false.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isFunction : function(v){
            return toString.apply(v) === '[object Function]';
        },

<span id='Ext-method-isNumber'>        /**
</span>         * Returns true if the passed value is a number. Returns false for non-finite numbers.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isNumber : function(v){
            return typeof v === 'number' &amp;&amp; isFinite(v);
        },

<span id='Ext-method-isString'>        /**
</span>         * Returns true if the passed value is a string.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isString : function(v){
            return typeof v === 'string';
        },

<span id='Ext-method-isBoolean'>        /**
</span>         * Returns true if the passed value is a boolean.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isBoolean : function(v){
            return typeof v === 'boolean';
        },

<span id='Ext-method-isElement'>        /**
</span>         * Returns true if the passed value is an HTMLElement
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isElement : function(v) {
            return v ? !!v.tagName : false;
        },

<span id='Ext-method-isDefined'>        /**
</span>         * Returns true if the passed value is not undefined.
         * @param {Mixed} value The value to test
         * @return {Boolean}
         */
        isDefined : function(v){
            return typeof v !== 'undefined';
        },

<span id='Ext-property-isOpera'>        /**
</span>         * True if the detected browser is Opera.
         * @type Boolean
         */
        isOpera : isOpera,
<span id='Ext-property-isWebKit'>        /**
</span>         * True if the detected browser uses WebKit.
         * @type Boolean
         */
        isWebKit : isWebKit,
<span id='Ext-property-isChrome'>        /**
</span>         * True if the detected browser is Chrome.
         * @type Boolean
         */
        isChrome : isChrome,
<span id='Ext-property-isSafari'>        /**
</span>         * True if the detected browser is Safari.
         * @type Boolean
         */
        isSafari : isSafari,
<span id='Ext-property-isSafari3'>        /**
</span>         * True if the detected browser is Safari 3.x.
         * @type Boolean
         */
        isSafari3 : isSafari3,
<span id='Ext-property-isSafari4'>        /**
</span>         * True if the detected browser is Safari 4.x.
         * @type Boolean
         */
        isSafari4 : isSafari4,
<span id='Ext-property-isSafari2'>        /**
</span>         * True if the detected browser is Safari 2.x.
         * @type Boolean
         */
        isSafari2 : isSafari2,
<span id='Ext-property-isIE'>        /**
</span>         * True if the detected browser is Internet Explorer.
         * @type Boolean
         */
        isIE : isIE,
<span id='Ext-property-isIE6'>        /**
</span>         * True if the detected browser is Internet Explorer 6.x.
         * @type Boolean
         */
        isIE6 : isIE6,
<span id='Ext-property-isIE7'>        /**
</span>         * True if the detected browser is Internet Explorer 7.x.
         * @type Boolean
         */
        isIE7 : isIE7,
<span id='Ext-property-isIE8'>        /**
</span>         * True if the detected browser is Internet Explorer 8.x.
         * @type Boolean
         */
        isIE8 : isIE8,
<span id='Ext-property-isIE9'>        /**
</span>         * True if the detected browser is Internet Explorer 9.x.
         * @type Boolean
         */
        isIE9 : isIE9,
        
<span id='Ext-property-isIE10'>        /**
</span>         * True if the detected browser is Internet Explorer 10.x
         * @type Boolean
         */
        isIE10 : isIE10,
        
<span id='Ext-property-isIE9m'>        /**
</span>         * True if the detected browser is Internet Explorer 9.x or lower
         * @type Boolean
         */
        isIE9m : isIE9m,
        
<span id='Ext-property-isIE10p'>        /**
</span>         * True if the detected browser is Internet Explorer 10.x or higher
         * @type Boolean
         */ 
        isIE10p : isIE &amp;&amp; !(isIE6 || isIE7 || isIE8 || isIE9),
        
        // IE10 quirks behaves like Gecko/WebKit quirks, so don't include it here
        // Used internally
        isIEQuirks: isIE &amp;&amp; (!isStrict &amp;&amp; (isIE6 || isIE7 || isIE8 || isIE9)),
                
<span id='Ext-property-isGecko'>        /**
</span>         * True if the detected browser uses the Gecko layout engine (e.g. Mozilla, Firefox).
         * @type Boolean
         */
        isGecko : isGecko,
<span id='Ext-property-isGecko2'>        /**
</span>         * True if the detected browser uses a pre-Gecko 1.9 layout engine (e.g. Firefox 2.x).
         * @type Boolean
         */
        isGecko2 : isGecko2,
<span id='Ext-property-isGecko3'>        /**
</span>         * True if the detected browser uses a Gecko 1.9+ layout engine (e.g. Firefox 3.x).
         * @type Boolean
         */
        isGecko3 : isGecko3,
<span id='Ext-property-isBorderBox'>        /**
</span>         * True if the detected browser is Internet Explorer running in non-strict mode.
         * @type Boolean
         */
        isBorderBox : isBorderBox,
<span id='Ext-property-isLinux'>        /**
</span>         * True if the detected platform is Linux.
         * @type Boolean
         */
        isLinux : isLinux,
<span id='Ext-property-isWindows'>        /**
</span>         * True if the detected platform is Windows.
         * @type Boolean
         */
        isWindows : isWindows,
<span id='Ext-property-isMac'>        /**
</span>         * True if the detected platform is Mac OS.
         * @type Boolean
         */
        isMac : isMac,
<span id='Ext-property-isAir'>        /**
</span>         * True if the detected platform is Adobe Air.
         * @type Boolean
         */
        isAir : isAir
    });

<span id='Ext-method-ns'>    /**
</span>     * Creates namespaces to be used for scoping variables and classes so that they are not global.
     * Specifying the last node of a namespace implicitly creates all other nodes. Usage:
     * &lt;pre&gt;&lt;code&gt;
Ext.namespace('Company', 'Company.data');
Ext.namespace('Company.data'); // equivalent and preferable to above syntax
Company.Widget = function() { ... }
Company.data.CustomStore = function(config) { ... }
&lt;/code&gt;&lt;/pre&gt;
     * @param {String} namespace1
     * @param {String} namespace2
     * @param {String} etc
     * @return {Object} The namespace object. (If multiple arguments are passed, this will be the last namespace created)
     * @method ns
     */
    Ext.ns = Ext.namespace;
})();

Ext.ns('Ext.util', 'Ext.lib', 'Ext.data', 'Ext.supports');

Ext.elCache = {};

<span id='Function'>/**
</span> * @class Function
 * These functions are available on every Function object (any JavaScript function).
 */
Ext.apply(Function.prototype, {
<span id='Function-method-createInterceptor'>     /**
</span>     * Creates an interceptor function. The passed function is called before the original one. If it returns false,
     * the original one is not called. The resulting function returns the results of the original function.
     * The passed function is called with the parameters of the original function. Example usage:
     * &lt;pre&gt;&lt;code&gt;
var sayHi = function(name){
    alert('Hi, ' + name);
}

sayHi('Fred'); // alerts &quot;Hi, Fred&quot;

// create a new function that validates input without
// directly modifying the original function:
var sayHiToFriend = sayHi.createInterceptor(function(name){
    return name == 'Brian';
});

sayHiToFriend('Fred');  // no alert
sayHiToFriend('Brian'); // alerts &quot;Hi, Brian&quot;
&lt;/code&gt;&lt;/pre&gt;
     * @param {Function} fcn The function to call before the original
     * @param {Object} scope (optional) The scope (&lt;code&gt;&lt;b&gt;this&lt;/b&gt;&lt;/code&gt; reference) in which the passed function is executed.
     * &lt;b&gt;If omitted, defaults to the scope in which the original function is called or the browser window.&lt;/b&gt;
     * @return {Function} The new function
     */
    createInterceptor : function(fcn, scope){
        var method = this;
        return !Ext.isFunction(fcn) ?
                this :
                function() {
                    var me = this,
                        args = arguments;
                    fcn.target = me;
                    fcn.method = method;
                    return (fcn.apply(scope || me || window, args) !== false) ?
                            method.apply(me || window, args) :
                            null;
                };
    },

<span id='Function-method-createCallback'>     /**
</span>     * Creates a callback that passes arguments[0], arguments[1], arguments[2], ...
     * Call directly on any function. Example: &lt;code&gt;myFunction.createCallback(arg1, arg2)&lt;/code&gt;
     * Will create a function that is bound to those 2 args. &lt;b&gt;If a specific scope is required in the
     * callback, use {@link #createDelegate} instead.&lt;/b&gt; The function returned by createCallback always
     * executes in the window scope.
     * &lt;p&gt;This method is required when you want to pass arguments to a callback function.  If no arguments
     * are needed, you can simply pass a reference to the function as a callback (e.g., callback: myFn).
     * However, if you tried to pass a function with arguments (e.g., callback: myFn(arg1, arg2)) the function
     * would simply execute immediately when the code is parsed. Example usage:
     * &lt;pre&gt;&lt;code&gt;
var sayHi = function(name){
    alert('Hi, ' + name);
}

// clicking the button alerts &quot;Hi, Fred&quot;
new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody(),
    handler: sayHi.createCallback('Fred')
});
&lt;/code&gt;&lt;/pre&gt;
     * @return {Function} The new function
    */
    createCallback : function(/*args...*/){
        // make args available, in function below
        var args = arguments,
            method = this;
        return function() {
            return method.apply(window, args);
        };
    },

<span id='Function-method-createDelegate'>    /**
</span>     * Creates a delegate (callback) that sets the scope to obj.
     * Call directly on any function. Example: &lt;code&gt;this.myFunction.createDelegate(this, [arg1, arg2])&lt;/code&gt;
     * Will create a function that is automatically scoped to obj so that the &lt;tt&gt;this&lt;/tt&gt; variable inside the
     * callback points to obj. Example usage:
     * &lt;pre&gt;&lt;code&gt;
var sayHi = function(name){
    // Note this use of &quot;this.text&quot; here.  This function expects to
    // execute within a scope that contains a text property.  In this
    // example, the &quot;this&quot; variable is pointing to the btn object that
    // was passed in createDelegate below.
    alert('Hi, ' + name + '. You clicked the &quot;' + this.text + '&quot; button.');
}

var btn = new Ext.Button({
    text: 'Say Hi',
    renderTo: Ext.getBody()
});

// This callback will execute in the scope of the
// button instance. Clicking the button alerts
// &quot;Hi, Fred. You clicked the &quot;Say Hi&quot; button.&quot;
btn.on('click', sayHi.createDelegate(btn, ['Fred']));
&lt;/code&gt;&lt;/pre&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;&lt;b&gt;this&lt;/b&gt;&lt;/code&gt; reference) in which the function is executed.
     * &lt;b&gt;If omitted, defaults to the browser window.&lt;/b&gt;
     * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
     * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
     * if a number the args are inserted at the specified position
     * @return {Function} The new function
     */
    createDelegate : function(obj, args, appendArgs){
        var method = this;
        return function() {
            var callArgs = args || arguments;
            if (appendArgs === true){
                callArgs = Array.prototype.slice.call(arguments, 0);
                callArgs = callArgs.concat(args);
            }else if (Ext.isNumber(appendArgs)){
                callArgs = Array.prototype.slice.call(arguments, 0); // copy arguments first
                var applyArgs = [appendArgs, 0].concat(args); // create method call params
                Array.prototype.splice.apply(callArgs, applyArgs); // splice them in
            }
            return method.apply(obj || window, callArgs);
        };
    },

<span id='Function-method-defer'>    /**
</span>     * Calls this function after the number of millseconds specified, optionally in a specific scope. Example usage:
     * &lt;pre&gt;&lt;code&gt;
var sayHi = function(name){
    alert('Hi, ' + name);
}

// executes immediately:
sayHi('Fred');

// executes after 2 seconds:
sayHi.defer(2000, this, ['Fred']);

// this syntax is sometimes useful for deferring
// execution of an anonymous function:
(function(){
    alert('Anonymous');
}).defer(100);
&lt;/code&gt;&lt;/pre&gt;
     * @param {Number} millis The number of milliseconds for the setTimeout call (if less than or equal to 0 the function is executed immediately)
     * @param {Object} scope (optional) The scope (&lt;code&gt;&lt;b&gt;this&lt;/b&gt;&lt;/code&gt; reference) in which the function is executed.
     * &lt;b&gt;If omitted, defaults to the browser window.&lt;/b&gt;
     * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
     * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
     * if a number the args are inserted at the specified position
     * @return {Number} The timeout id that can be used with clearTimeout
     */
    defer : function(millis, obj, args, appendArgs){
        var fn = this.createDelegate(obj, args, appendArgs);
        if(millis &gt; 0){
            return setTimeout(fn, millis);
        }
        fn();
        return 0;
    }
});

<span id='String'>/**
</span> * @class String
 * These functions are available on every String object.
 */
Ext.applyIf(String, {
<span id='String-static-method-format'>    /**
</span>     * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
     * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
     * &lt;pre&gt;&lt;code&gt;
var cls = 'my-class', text = 'Some text';
var s = String.format('&amp;lt;div class=&quot;{0}&quot;&gt;{1}&amp;lt;/div&gt;', cls, text);
// s now contains the string: '&amp;lt;div class=&quot;my-class&quot;&gt;Some text&amp;lt;/div&gt;'
     * &lt;/code&gt;&lt;/pre&gt;
     * @param {String} string The tokenized string to be formatted
     * @param {String} value1 The value to replace token {0}
     * @param {String} value2 Etc...
     * @return {String} The formatted string
     * @static
     */
    format : function(format){
        var args = Ext.toArray(arguments, 1);
        return format.replace(/\{(\d+)\}/g, function(m, i){
            return args[i];
        });
    }
});

<span id='Array'>/**
</span> * @class Array
 */
Ext.applyIf(Array.prototype, {
<span id='Array-method-indexOf'>    /**
</span>     * Checks whether or not the specified object exists in the array.
     * @param {Object} o The object to check for
     * @param {Number} from (Optional) The index at which to begin the search
     * @return {Number} The index of o in the array (or -1 if it is not found)
     */
    indexOf : function(o, from){
        var len = this.length;
        from = from || 0;
        from += (from &lt; 0) ? len : 0;
        for (; from &lt; len; ++from){
            if(this[from] === o){
                return from;
            }
        }
        return -1;
    },

<span id='Array-method-remove'>    /**
</span>     * Removes the specified object from the array.  If the object is not found nothing happens.
     * @param {Object} o The object to remove
     * @return {Array} this array
     */
    remove : function(o){
        var index = this.indexOf(o);
        if(index != -1){
            this.splice(index, 1);
        }
        return this;
    }
});
</pre>
</body>
</html>
